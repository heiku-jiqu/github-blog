import{S as $a,i as Qa,s as Ya,k as n,q as l,a as d,l as r,m as i,r as s,h as o,c as f,n as j,b as c,B as e,A as Qr}from"./index-39c5cc75.js";function Za(Ma){let x,rl,fo,te,il,po,oe,al,uo,v,cl,Be,dl,fl,Me,pl,ul,Ne,hl,ml,qe,El,vl,ho,le,We,bl,mo,se,_l,Eo,ne,Sl,vo,R,wl,Ae,yl,Il,bo,re,Cl,_o,H,Ol,$e,kl,Pl,So,ie,Dl,wo,ae,Ll,yo,ce,Tl,Io,de,jl,Co,fe,gl,Oo,h,Qe,Ye,xl,Rl,Ze,G,Hl,Fe,Gl,Ul,Ke,Jl,Bl,ze,$,Ml,Ve,Nl,ql,Wl,Xe,Q,Al,et,$l,Ql,Yl,tt,ot,Zl,Fl,lt,Y,Kl,st,zl,Vl,Xl,nt,Z,es,rt,ts,os,ls,it,at,ss,ko,pe,ns,Po,m,rs,ct,is,as,dt,cs,ds,ft,fs,ps,pt,us,hs,ut,ms,Es,Do,O,vs,ht,bs,_s,mt,Ss,ws,Lo,k,ys,Et,Is,Cs,vt,Os,ks,To,F,Na=`<code class="language-bash"><span class="token function">sleep</span> <span class="token number">5</span> <span class="token operator">&amp;</span> <span class="token function">sleep</span> <span class="token number">6</span> <span class="token operator">&amp;</span>
<span class="token function">kill</span> %2 <span class="token comment"># terminate JOBSPEC 2 which is 'sleep 6'</span>
<span class="token function">jobs</span>
<span class="token comment"># shows sleep 5 is running and sleep 6 is terminated</span></code>`,jo,ue,Ps,go,K,qa=`<code class="language-bash"><span class="token function">sleep</span> <span class="token number">5</span> <span class="token operator">&amp;</span> <span class="token function">sleep</span> <span class="token number">6</span> <span class="token operator">&amp;</span>
<span class="token function">kill</span> <span class="token parameter variable">-SIGSTOP</span> %1 <span class="token comment"># send SIGSTOP to JOBSPEC 1</span>
<span class="token function">jobs</span> <span class="token comment"># sleep 5 is stopped, sleep 6 is still running</span>
<span class="token function">kill</span> <span class="token parameter variable">-SIGCONT</span> %1
<span class="token function">jobs</span> <span class="token comment"># sleep 5 continues running</span></code>`,xo,_,Ds,bt,Ls,Ts,_t,js,gs,St,xs,Rs,Ro,S,Hs,wt,Gs,Us,yt,Js,Bs,It,Ms,Ns,Ho,he,qs,Go,me,Ws,Uo,U,As,Ct,$s,Qs,Jo,Ee,Ys,Bo,P,Ot,Zs,Fs,kt,Ks,zs,Pt,Vs,Mo,J,Xs,Dt,en,tn,No,ve,on,qo,D,be,Lt,ln,sn,nn,_e,Tt,rn,an,cn,Se,jt,dn,fn,Wo,w,pn,gt,un,hn,xt,mn,En,Rt,vn,bn,Ao,b,_n,Ht,Sn,wn,Gt,yn,In,Ut,Cn,On,Jt,kn,Pn,$o,y,Dn,Bt,Ln,Tn,Mt,jn,gn,Nt,xn,Rn,Qo,we,Hn,Yo,p,ye,qt,Gn,Un,Jn,Ie,Wt,Bn,Mn,Nn,Ce,At,qn,Wn,An,Oe,$t,$n,Qn,Yn,ke,Qt,Zn,Fn,Kn,Pe,Yt,zn,Vn,Xn,De,Zt,er,tr,or,Le,Ft,lr,sr,nr,B,Kt,rr,ir,zt,ar,cr,dr,Te,Vt,fr,pr,ur,je,Xt,hr,mr,Er,ge,eo,vr,br,Zo,xe,_r,Fo,g,Sr,to,wr,yr,oo,Ir,Ko,Re,Cr,zo,I,lo,z,Or,kr,so,V,Pr,Dr,no,X,Lr,Tr,ro,ee,jr;return{c(){x=n("h1"),rl=l(Ba),fo=d(),te=n("h2"),il=l("Introduction"),po=d(),oe=n("p"),al=l("Recently wondered whether a single docker container is able to run multiple executables, hence went to dig deeper into how Linux background processes work."),uo=d(),v=n("p"),cl=l("TL;DR: Yes, you can do so by appending "),Be=n("code"),dl=l("&"),fl=l(" to your commands (except the last command) in "),Me=n("code"),pl=l("CMD"),ul=l(" or "),Ne=n("code"),hl=l("ENTRYPOINT"),ml=l(" or "),qe=n("code"),El=l(".sh"),vl=l(" scripts."),ho=d(),le=n("p"),We=n("em"),bl=l("note: the concepts are only for Linux, Windows will have its own alternatives that are different"),mo=d(),se=n("h2"),_l=l("Concepts"),Eo=d(),ne=n("h3"),Sl=l("Processes"),vo=d(),R=n("p"),wl=l(`Every running program in Linux is a process.
Every process has an associated `),Ae=n("code"),yl=l("PID"),Il=l("."),bo=d(),re=n("h3"),Cl=l("Jobs"),_o=d(),H=n("p"),Ol=l(`A job is the group of processes that runs when you run a command in the shell
(can be 1 process, can be multiple processes if you run complex commands).
Every job has an associated `),$e=n("code"),kl=l("JOBSPEC"),Pl=l("."),So=d(),ie=n("h3"),Dl=l("Signals"),wo=d(),ae=n("p"),Ll=l("Every running process can receive \u201Csignals\u201D that is sent from another process, through the OS and to the running process."),yo=d(),ce=n("p"),Tl=l("These signals can be caught by the running program and handled accordingly (handlers can be written by programmers)."),Io=d(),de=n("p"),jl=l(`Whenever the OS sends a signal to the running process, the OS will interrupt the running process\u2019 flow of execution and ask it to handle the signal.
Imagine the OS is executing the running process\u2019 code line by line, and at a certain line the OS suddenly \u201Cdrops\u201D the execution and ask the process\u2019 code to handle the signal.`),Co=d(),fe=n("p"),gl=l("Common signals:"),Oo=d(),h=n("ul"),Qe=n("li"),Ye=n("p"),xl=l("SIGKILL Forcefully stops the process (cannot be caught by process)"),Rl=d(),Ze=n("li"),G=n("p"),Hl=l("SIGTERM (Default signal used by "),Fe=n("code"),Gl=l("kill"),Ul=l(" command) Terminates the process and runs any handlers, usually sent from "),Ke=n("code"),Jl=l("kill"),Bl=d(),ze=n("li"),$=n("p"),Ml=l("SIGINT ("),Ve=n("code"),Nl=l("Ctrl+C"),ql=l(") Terminates the process and runs any handlers, usually sent from keyboard"),Wl=d(),Xe=n("li"),Q=n("p"),Al=l("SIGQUIT ("),et=n("code"),$l=l("Ctrl+\\"),Ql=l(") Same as SIGINT, but with additional error dump."),Yl=d(),tt=n("li"),ot=n("p"),Zl=l("SIGHUP Indicates that terminal is disconnected, usually sent automatically when terminal emulator is closed"),Fl=d(),lt=n("li"),Y=n("p"),Kl=l("SIGSTOP Stop the process, the process is "),st=n("em"),zl=l("paused"),Vl=l(" and can be resumed, and this signal cannot be caught by process"),Xl=d(),nt=n("li"),Z=n("p"),es=l("SIGTSTP ("),rt=n("code"),ts=l("Ctrl+Z"),os=l(") Stop the process (i.e. paused) from the terminal, can be caught by the process to run handlers"),ls=d(),it=n("li"),at=n("p"),ss=l("SIGCONT Resumes the stopped process"),ko=d(),pe=n("h2"),ns=l("Running multiple commands"),Po=d(),m=n("p"),rs=l("To run multiple commands, append commands using "),ct=n("code"),is=l("&"),as=l(", for example: "),dt=n("code"),cs=l("sleep 5 & echo hello"),ds=l(`.
`),ft=n("code"),fs=l("&"),ps=l(" sends the preceding command into the background as a job, and also print out the JOBSPEC (aka job number) and PID (aka process ID) in the form "),pt=n("code"),us=l("[JOBSPEC] PID"),hs=l(`.
To see the list of running jobs, use `),ut=n("code"),ms=l("jobs"),Es=l(" command, which will show the JOBSPEC and the corresponding command."),Do=d(),O=n("p"),vs=l("Note that you can send all commands to the background: "),ht=n("code"),bs=l("sleep 5 & sleep 6 &"),_s=l(`, which will unblock your terminal immediately.
To wait for all jobs to finish (e.g. when using in scripts), just execute `),mt=n("code"),Ss=l("wait"),ws=l(", and it will block until all jobs are finished."),Lo=d(),k=n("p"),ys=l("If there is a long running job that you want to terminate, send SIGTERM signal with "),Et=n("code"),Is=l("kill %n"),Cs=l(" where "),vt=n("code"),Os=l("n"),ks=l(" is the JOBSPEC."),To=d(),F=n("pre"),jo=d(),ue=n("p"),Ps=l(`If there is a long running job that you want to pause, send the SIGTSTP signal, which will pause the process.
To resume, send SIGCONT to the stopped job.`),go=d(),K=n("pre"),xo=d(),_=n("p"),Ds=l("In the case where you\u2019ve already ran a program and it is blocking, it is possible to stop it by using "),bt=n("code"),Ls=l("Ctrl+Z"),Ts=l(" which sends SIGTSTP. Then you can either continue running the program in the foreground using "),_t=n("code"),js=l("fg JOBSPEC"),gs=l(" or in the background using "),St=n("code"),xs=l("bg JOBSPEC"),Rs=l("."),Ro=d(),S=n("p"),Hs=l(`One final note about using these in Docker. Docker containers will exit when there are no more foreground processes that are running (i.e. not blocked).
So if you run all commands/jobs/processes in the background using `),wt=n("code"),Gs=l("&"),Us=l(`, the container will just exit immediately.
To resolve this, either use `),yt=n("code"),Js=l("wait"),Bs=l(" to block until all jobs are completed, or don\u2019t "),It=n("code"),Ms=l("&"),Ns=l(" the last command, depending on your use case."),Ho=d(),he=n("h2"),qs=l("Redirection"),Go=d(),me=n("p"),Ws=l("Small detour on redirecting stdin/out/err, so that instead of stdout printing to terminal, you can redirect to print into a file, or stdin reading in from terminal, you can read in from a file."),Uo=d(),U=n("p"),As=l("When linux system does any reading or writing, it needs a "),Ct=n("em"),$s=l("file descriptor"),Qs=l(" to identify where it is reading/writing from, which are basically just non negative integers."),Jo=d(),Ee=n("p"),Ys=l("There are 3 standard file descriptors:"),Bo=d(),P=n("ul"),Ot=n("li"),Zs=l("0 for stdin"),Fs=d(),kt=n("li"),Ks=l("1 for stdout"),zs=d(),Pt=n("li"),Vs=l("2 for stderr"),Mo=d(),J=n("p"),Xs=l("If there are readable/writable files opened, more file descriptors will be added sequentially ("),Dt=n("code"),en=l("ls -l /proc/$$/fd"),tn=l(" to see list of file descriptors)"),No=d(),ve=n("p"),on=l("To redirect, we use the three operators below:"),qo=d(),D=n("ul"),be=n("li"),Lt=n("code"),ln=l("<"),sn=l(": redirect input"),nn=d(),_e=n("li"),Tt=n("code"),rn=l(">"),an=l(": redirect output, default LHS file descriptor is 1"),cn=d(),Se=n("li"),jt=n("code"),dn=l(">>"),fn=l(": redirect and append, default LHS file descriptor is 1"),Wo=d(),w=n("p"),pn=l("Use "),gt=n("code"),un=l("file_descriptor>filename"),hn=l(" to redirect to a file, e.g. "),xt=n("code"),mn=l("1>log.txt"),En=l(" (same as "),Rt=n("code"),vn=l(">log.txt"),bn=l(") to redirect stdout to log.txt."),Ao=d(),b=n("p"),_n=l("Use "),Ht=n("code"),Sn=l("file_descriptor>&file_descriptor"),wn=l(" to redirect to another file descriptor from LHS to RHS (note the "),Gt=n("code"),yn=l("&"),In=l(" in RHS) e.g. "),Ut=n("code"),Cn=l("2>&1"),On=l(" redirects file descriptor "),Jt=n("code"),kn=l("2"),Pn=l(" which is stderr to stdout."),$o=d(),y=n("p"),Dn=l("Use "),Bt=n("code"),Ln=l("sort < file_to_sort.txt"),Tn=l(" to redirect "),Mt=n("code"),jn=l("file_to_sort.txt"),gn=l(" into "),Nt=n("code"),xn=l("sort"),Rn=l("\u2019s stdin."),Qo=d(),we=n("h2"),Hn=l("Commands Summary"),Yo=d(),p=n("ul"),ye=n("li"),qt=n("code"),Gn=l("&"),Un=l(": Runs preceding command in the background"),Jn=d(),Ie=n("li"),Wt=n("code"),Bn=l("kill"),Mn=l(": Sends specified signal to specified job/process, defaults to SIGTERM"),Nn=d(),Ce=n("li"),At=n("code"),qn=l("jobs"),Wn=l(": List all jobs"),An=d(),Oe=n("li"),$t=n("code"),$n=l("ps"),Qn=l(": List all processes"),Yn=d(),ke=n("li"),Qt=n("code"),Zn=l("bg"),Fn=l(": Continues a job in the background"),Kn=d(),Pe=n("li"),Yt=n("code"),zn=l("fg"),Vn=l(": Continues a job in the foreground"),Xn=d(),De=n("li"),Zt=n("code"),er=l("wait"),tr=l(": Wait for all jobs to finish (i.e. blocks until all jobs are finished)"),or=d(),Le=n("li"),Ft=n("code"),lr=l("disown"),sr=l(": Remove job(s) from the jobs list, process still connected to terminal"),nr=d(),B=n("li"),Kt=n("code"),rr=l("nohup"),ir=l(": Separates the process from the terminal by closing stdin, redirecting stdin and stdout into a file "),zt=n("code"),ar=l("nohup.out"),cr=l(", prevents SIGHUP from reaching process, but job is still under job list"),dr=d(),Te=n("li"),Vt=n("code"),fr=l("&&"),pr=l(": Runs RHS command only if LHS succeeds"),ur=d(),je=n("li"),Xt=n("code"),hr=l("||"),mr=l(": Runs RHS command only if LHS fails"),Er=d(),ge=n("li"),eo=n("code"),vr=l(";"),br=l(": Runs RHS command after LHS, regardless whether it succeeds or fails"),Zo=d(),xe=n("h2"),_r=l("Useful idioms"),Fo=d(),g=n("p"),Sr=l("Send a signal to all jobs: "),to=n("code"),wr=l("kill $(jobs -p)"),yr=l(" or "),oo=n("code"),Ir=l("jobs -p | xargs kill"),Ko=d(),Re=n("h2"),Cr=l("References"),zo=d(),I=n("ul"),lo=n("li"),z=n("a"),Or=l("glibc docs describing signals"),kr=d(),so=n("li"),V=n("a"),Pr=l("man 7 pages on signals"),Dr=d(),no=n("li"),X=n("a"),Lr=l("SO question on SIGTERM and SIGQUIT"),Tr=d(),ro=n("li"),ee=n("a"),jr=l("SO question on disown and nohup"),this.h()},l(t){x=r(t,"H1",{});var a=i(x);rl=s(a,Ba),a.forEach(o),fo=f(t),te=r(t,"H2",{});var Yr=i(te);il=s(Yr,"Introduction"),Yr.forEach(o),po=f(t),oe=r(t,"P",{});var Zr=i(oe);al=s(Zr,"Recently wondered whether a single docker container is able to run multiple executables, hence went to dig deeper into how Linux background processes work."),Zr.forEach(o),uo=f(t),v=r(t,"P",{});var L=i(v);cl=s(L,"TL;DR: Yes, you can do so by appending "),Be=r(L,"CODE",{});var Fr=i(Be);dl=s(Fr,"&"),Fr.forEach(o),fl=s(L," to your commands (except the last command) in "),Me=r(L,"CODE",{});var Kr=i(Me);pl=s(Kr,"CMD"),Kr.forEach(o),ul=s(L," or "),Ne=r(L,"CODE",{});var zr=i(Ne);hl=s(zr,"ENTRYPOINT"),zr.forEach(o),ml=s(L," or "),qe=r(L,"CODE",{});var Vr=i(qe);El=s(Vr,".sh"),Vr.forEach(o),vl=s(L," scripts."),L.forEach(o),ho=f(t),le=r(t,"P",{});var Xr=i(le);We=r(Xr,"EM",{});var ei=i(We);bl=s(ei,"note: the concepts are only for Linux, Windows will have its own alternatives that are different"),ei.forEach(o),Xr.forEach(o),mo=f(t),se=r(t,"H2",{});var ti=i(se);_l=s(ti,"Concepts"),ti.forEach(o),Eo=f(t),ne=r(t,"H3",{});var oi=i(ne);Sl=s(oi,"Processes"),oi.forEach(o),vo=f(t),R=r(t,"P",{});var Vo=i(R);wl=s(Vo,`Every running program in Linux is a process.
Every process has an associated `),Ae=r(Vo,"CODE",{});var li=i(Ae);yl=s(li,"PID"),li.forEach(o),Il=s(Vo,"."),Vo.forEach(o),bo=f(t),re=r(t,"H3",{});var si=i(re);Cl=s(si,"Jobs"),si.forEach(o),_o=f(t),H=r(t,"P",{});var Xo=i(H);Ol=s(Xo,`A job is the group of processes that runs when you run a command in the shell
(can be 1 process, can be multiple processes if you run complex commands).
Every job has an associated `),$e=r(Xo,"CODE",{});var ni=i($e);kl=s(ni,"JOBSPEC"),ni.forEach(o),Pl=s(Xo,"."),Xo.forEach(o),So=f(t),ie=r(t,"H3",{});var ri=i(ie);Dl=s(ri,"Signals"),ri.forEach(o),wo=f(t),ae=r(t,"P",{});var ii=i(ae);Ll=s(ii,"Every running process can receive \u201Csignals\u201D that is sent from another process, through the OS and to the running process."),ii.forEach(o),yo=f(t),ce=r(t,"P",{});var ai=i(ce);Tl=s(ai,"These signals can be caught by the running program and handled accordingly (handlers can be written by programmers)."),ai.forEach(o),Io=f(t),de=r(t,"P",{});var ci=i(de);jl=s(ci,`Whenever the OS sends a signal to the running process, the OS will interrupt the running process\u2019 flow of execution and ask it to handle the signal.
Imagine the OS is executing the running process\u2019 code line by line, and at a certain line the OS suddenly \u201Cdrops\u201D the execution and ask the process\u2019 code to handle the signal.`),ci.forEach(o),Co=f(t),fe=r(t,"P",{});var di=i(fe);gl=s(di,"Common signals:"),di.forEach(o),Oo=f(t),h=r(t,"UL",{});var E=i(h);Qe=r(E,"LI",{});var fi=i(Qe);Ye=r(fi,"P",{});var pi=i(Ye);xl=s(pi,"SIGKILL Forcefully stops the process (cannot be caught by process)"),pi.forEach(o),fi.forEach(o),Rl=f(E),Ze=r(E,"LI",{});var ui=i(Ze);G=r(ui,"P",{});var io=i(G);Hl=s(io,"SIGTERM (Default signal used by "),Fe=r(io,"CODE",{});var hi=i(Fe);Gl=s(hi,"kill"),hi.forEach(o),Ul=s(io," command) Terminates the process and runs any handlers, usually sent from "),Ke=r(io,"CODE",{});var mi=i(Ke);Jl=s(mi,"kill"),mi.forEach(o),io.forEach(o),ui.forEach(o),Bl=f(E),ze=r(E,"LI",{});var Ei=i(ze);$=r(Ei,"P",{});var el=i($);Ml=s(el,"SIGINT ("),Ve=r(el,"CODE",{});var vi=i(Ve);Nl=s(vi,"Ctrl+C"),vi.forEach(o),ql=s(el,") Terminates the process and runs any handlers, usually sent from keyboard"),el.forEach(o),Ei.forEach(o),Wl=f(E),Xe=r(E,"LI",{});var bi=i(Xe);Q=r(bi,"P",{});var tl=i(Q);Al=s(tl,"SIGQUIT ("),et=r(tl,"CODE",{});var _i=i(et);$l=s(_i,"Ctrl+\\"),_i.forEach(o),Ql=s(tl,") Same as SIGINT, but with additional error dump."),tl.forEach(o),bi.forEach(o),Yl=f(E),tt=r(E,"LI",{});var Si=i(tt);ot=r(Si,"P",{});var wi=i(ot);Zl=s(wi,"SIGHUP Indicates that terminal is disconnected, usually sent automatically when terminal emulator is closed"),wi.forEach(o),Si.forEach(o),Fl=f(E),lt=r(E,"LI",{});var yi=i(lt);Y=r(yi,"P",{});var ol=i(Y);Kl=s(ol,"SIGSTOP Stop the process, the process is "),st=r(ol,"EM",{});var Ii=i(st);zl=s(Ii,"paused"),Ii.forEach(o),Vl=s(ol," and can be resumed, and this signal cannot be caught by process"),ol.forEach(o),yi.forEach(o),Xl=f(E),nt=r(E,"LI",{});var Ci=i(nt);Z=r(Ci,"P",{});var ll=i(Z);es=s(ll,"SIGTSTP ("),rt=r(ll,"CODE",{});var Oi=i(rt);ts=s(Oi,"Ctrl+Z"),Oi.forEach(o),os=s(ll,") Stop the process (i.e. paused) from the terminal, can be caught by the process to run handlers"),ll.forEach(o),Ci.forEach(o),ls=f(E),it=r(E,"LI",{});var ki=i(it);at=r(ki,"P",{});var Pi=i(at);ss=s(Pi,"SIGCONT Resumes the stopped process"),Pi.forEach(o),ki.forEach(o),E.forEach(o),ko=f(t),pe=r(t,"H2",{});var Di=i(pe);ns=s(Di,"Running multiple commands"),Di.forEach(o),Po=f(t),m=r(t,"P",{});var C=i(m);rs=s(C,"To run multiple commands, append commands using "),ct=r(C,"CODE",{});var Li=i(ct);is=s(Li,"&"),Li.forEach(o),as=s(C,", for example: "),dt=r(C,"CODE",{});var Ti=i(dt);cs=s(Ti,"sleep 5 & echo hello"),Ti.forEach(o),ds=s(C,`.
`),ft=r(C,"CODE",{});var ji=i(ft);fs=s(ji,"&"),ji.forEach(o),ps=s(C," sends the preceding command into the background as a job, and also print out the JOBSPEC (aka job number) and PID (aka process ID) in the form "),pt=r(C,"CODE",{});var gi=i(pt);us=s(gi,"[JOBSPEC] PID"),gi.forEach(o),hs=s(C,`.
To see the list of running jobs, use `),ut=r(C,"CODE",{});var xi=i(ut);ms=s(xi,"jobs"),xi.forEach(o),Es=s(C," command, which will show the JOBSPEC and the corresponding command."),C.forEach(o),Do=f(t),O=r(t,"P",{});var He=i(O);vs=s(He,"Note that you can send all commands to the background: "),ht=r(He,"CODE",{});var Ri=i(ht);bs=s(Ri,"sleep 5 & sleep 6 &"),Ri.forEach(o),_s=s(He,`, which will unblock your terminal immediately.
To wait for all jobs to finish (e.g. when using in scripts), just execute `),mt=r(He,"CODE",{});var Hi=i(mt);Ss=s(Hi,"wait"),Hi.forEach(o),ws=s(He,", and it will block until all jobs are finished."),He.forEach(o),Lo=f(t),k=r(t,"P",{});var Ge=i(k);ys=s(Ge,"If there is a long running job that you want to terminate, send SIGTERM signal with "),Et=r(Ge,"CODE",{});var Gi=i(Et);Is=s(Gi,"kill %n"),Gi.forEach(o),Cs=s(Ge," where "),vt=r(Ge,"CODE",{});var Ui=i(vt);Os=s(Ui,"n"),Ui.forEach(o),ks=s(Ge," is the JOBSPEC."),Ge.forEach(o),To=f(t),F=r(t,"PRE",{class:!0});var Wa=i(F);Wa.forEach(o),jo=f(t),ue=r(t,"P",{});var Ji=i(ue);Ps=s(Ji,`If there is a long running job that you want to pause, send the SIGTSTP signal, which will pause the process.
To resume, send SIGCONT to the stopped job.`),Ji.forEach(o),go=f(t),K=r(t,"PRE",{class:!0});var Aa=i(K);Aa.forEach(o),xo=f(t),_=r(t,"P",{});var M=i(_);Ds=s(M,"In the case where you\u2019ve already ran a program and it is blocking, it is possible to stop it by using "),bt=r(M,"CODE",{});var Bi=i(bt);Ls=s(Bi,"Ctrl+Z"),Bi.forEach(o),Ts=s(M," which sends SIGTSTP. Then you can either continue running the program in the foreground using "),_t=r(M,"CODE",{});var Mi=i(_t);js=s(Mi,"fg JOBSPEC"),Mi.forEach(o),gs=s(M," or in the background using "),St=r(M,"CODE",{});var Ni=i(St);xs=s(Ni,"bg JOBSPEC"),Ni.forEach(o),Rs=s(M,"."),M.forEach(o),Ro=f(t),S=r(t,"P",{});var N=i(S);Hs=s(N,`One final note about using these in Docker. Docker containers will exit when there are no more foreground processes that are running (i.e. not blocked).
So if you run all commands/jobs/processes in the background using `),wt=r(N,"CODE",{});var qi=i(wt);Gs=s(qi,"&"),qi.forEach(o),Us=s(N,`, the container will just exit immediately.
To resolve this, either use `),yt=r(N,"CODE",{});var Wi=i(yt);Js=s(Wi,"wait"),Wi.forEach(o),Bs=s(N," to block until all jobs are completed, or don\u2019t "),It=r(N,"CODE",{});var Ai=i(It);Ms=s(Ai,"&"),Ai.forEach(o),Ns=s(N," the last command, depending on your use case."),N.forEach(o),Ho=f(t),he=r(t,"H2",{});var $i=i(he);qs=s($i,"Redirection"),$i.forEach(o),Go=f(t),me=r(t,"P",{});var Qi=i(me);Ws=s(Qi,"Small detour on redirecting stdin/out/err, so that instead of stdout printing to terminal, you can redirect to print into a file, or stdin reading in from terminal, you can read in from a file."),Qi.forEach(o),Uo=f(t),U=r(t,"P",{});var sl=i(U);As=s(sl,"When linux system does any reading or writing, it needs a "),Ct=r(sl,"EM",{});var Yi=i(Ct);$s=s(Yi,"file descriptor"),Yi.forEach(o),Qs=s(sl," to identify where it is reading/writing from, which are basically just non negative integers."),sl.forEach(o),Jo=f(t),Ee=r(t,"P",{});var Zi=i(Ee);Ys=s(Zi,"There are 3 standard file descriptors:"),Zi.forEach(o),Bo=f(t),P=r(t,"UL",{});var Ue=i(P);Ot=r(Ue,"LI",{});var Fi=i(Ot);Zs=s(Fi,"0 for stdin"),Fi.forEach(o),Fs=f(Ue),kt=r(Ue,"LI",{});var Ki=i(kt);Ks=s(Ki,"1 for stdout"),Ki.forEach(o),zs=f(Ue),Pt=r(Ue,"LI",{});var zi=i(Pt);Vs=s(zi,"2 for stderr"),zi.forEach(o),Ue.forEach(o),Mo=f(t),J=r(t,"P",{});var nl=i(J);Xs=s(nl,"If there are readable/writable files opened, more file descriptors will be added sequentially ("),Dt=r(nl,"CODE",{});var Vi=i(Dt);en=s(Vi,"ls -l /proc/$$/fd"),Vi.forEach(o),tn=s(nl," to see list of file descriptors)"),nl.forEach(o),No=f(t),ve=r(t,"P",{});var Xi=i(ve);on=s(Xi,"To redirect, we use the three operators below:"),Xi.forEach(o),qo=f(t),D=r(t,"UL",{});var Je=i(D);be=r(Je,"LI",{});var gr=i(be);Lt=r(gr,"CODE",{});var ea=i(Lt);ln=s(ea,"<"),ea.forEach(o),sn=s(gr,": redirect input"),gr.forEach(o),nn=f(Je),_e=r(Je,"LI",{});var xr=i(_e);Tt=r(xr,"CODE",{});var ta=i(Tt);rn=s(ta,">"),ta.forEach(o),an=s(xr,": redirect output, default LHS file descriptor is 1"),xr.forEach(o),cn=f(Je),Se=r(Je,"LI",{});var Rr=i(Se);jt=r(Rr,"CODE",{});var oa=i(jt);dn=s(oa,">>"),oa.forEach(o),fn=s(Rr,": redirect and append, default LHS file descriptor is 1"),Rr.forEach(o),Je.forEach(o),Wo=f(t),w=r(t,"P",{});var q=i(w);pn=s(q,"Use "),gt=r(q,"CODE",{});var la=i(gt);un=s(la,"file_descriptor>filename"),la.forEach(o),hn=s(q," to redirect to a file, e.g. "),xt=r(q,"CODE",{});var sa=i(xt);mn=s(sa,"1>log.txt"),sa.forEach(o),En=s(q," (same as "),Rt=r(q,"CODE",{});var na=i(Rt);vn=s(na,">log.txt"),na.forEach(o),bn=s(q,") to redirect stdout to log.txt."),q.forEach(o),Ao=f(t),b=r(t,"P",{});var T=i(b);_n=s(T,"Use "),Ht=r(T,"CODE",{});var ra=i(Ht);Sn=s(ra,"file_descriptor>&file_descriptor"),ra.forEach(o),wn=s(T," to redirect to another file descriptor from LHS to RHS (note the "),Gt=r(T,"CODE",{});var ia=i(Gt);yn=s(ia,"&"),ia.forEach(o),In=s(T," in RHS) e.g. "),Ut=r(T,"CODE",{});var aa=i(Ut);Cn=s(aa,"2>&1"),aa.forEach(o),On=s(T," redirects file descriptor "),Jt=r(T,"CODE",{});var ca=i(Jt);kn=s(ca,"2"),ca.forEach(o),Pn=s(T," which is stderr to stdout."),T.forEach(o),$o=f(t),y=r(t,"P",{});var W=i(y);Dn=s(W,"Use "),Bt=r(W,"CODE",{});var da=i(Bt);Ln=s(da,"sort < file_to_sort.txt"),da.forEach(o),Tn=s(W," to redirect "),Mt=r(W,"CODE",{});var fa=i(Mt);jn=s(fa,"file_to_sort.txt"),fa.forEach(o),gn=s(W," into "),Nt=r(W,"CODE",{});var pa=i(Nt);xn=s(pa,"sort"),pa.forEach(o),Rn=s(W,"\u2019s stdin."),W.forEach(o),Qo=f(t),we=r(t,"H2",{});var ua=i(we);Hn=s(ua,"Commands Summary"),ua.forEach(o),Yo=f(t),p=r(t,"UL",{});var u=i(p);ye=r(u,"LI",{});var Hr=i(ye);qt=r(Hr,"CODE",{});var ha=i(qt);Gn=s(ha,"&"),ha.forEach(o),Un=s(Hr,": Runs preceding command in the background"),Hr.forEach(o),Jn=f(u),Ie=r(u,"LI",{});var Gr=i(Ie);Wt=r(Gr,"CODE",{});var ma=i(Wt);Bn=s(ma,"kill"),ma.forEach(o),Mn=s(Gr,": Sends specified signal to specified job/process, defaults to SIGTERM"),Gr.forEach(o),Nn=f(u),Ce=r(u,"LI",{});var Ur=i(Ce);At=r(Ur,"CODE",{});var Ea=i(At);qn=s(Ea,"jobs"),Ea.forEach(o),Wn=s(Ur,": List all jobs"),Ur.forEach(o),An=f(u),Oe=r(u,"LI",{});var Jr=i(Oe);$t=r(Jr,"CODE",{});var va=i($t);$n=s(va,"ps"),va.forEach(o),Qn=s(Jr,": List all processes"),Jr.forEach(o),Yn=f(u),ke=r(u,"LI",{});var Br=i(ke);Qt=r(Br,"CODE",{});var ba=i(Qt);Zn=s(ba,"bg"),ba.forEach(o),Fn=s(Br,": Continues a job in the background"),Br.forEach(o),Kn=f(u),Pe=r(u,"LI",{});var Mr=i(Pe);Yt=r(Mr,"CODE",{});var _a=i(Yt);zn=s(_a,"fg"),_a.forEach(o),Vn=s(Mr,": Continues a job in the foreground"),Mr.forEach(o),Xn=f(u),De=r(u,"LI",{});var Nr=i(De);Zt=r(Nr,"CODE",{});var Sa=i(Zt);er=s(Sa,"wait"),Sa.forEach(o),tr=s(Nr,": Wait for all jobs to finish (i.e. blocks until all jobs are finished)"),Nr.forEach(o),or=f(u),Le=r(u,"LI",{});var qr=i(Le);Ft=r(qr,"CODE",{});var wa=i(Ft);lr=s(wa,"disown"),wa.forEach(o),sr=s(qr,": Remove job(s) from the jobs list, process still connected to terminal"),qr.forEach(o),nr=f(u),B=r(u,"LI",{});var ao=i(B);Kt=r(ao,"CODE",{});var ya=i(Kt);rr=s(ya,"nohup"),ya.forEach(o),ir=s(ao,": Separates the process from the terminal by closing stdin, redirecting stdin and stdout into a file "),zt=r(ao,"CODE",{});var Ia=i(zt);ar=s(Ia,"nohup.out"),Ia.forEach(o),cr=s(ao,", prevents SIGHUP from reaching process, but job is still under job list"),ao.forEach(o),dr=f(u),Te=r(u,"LI",{});var Wr=i(Te);Vt=r(Wr,"CODE",{});var Ca=i(Vt);fr=s(Ca,"&&"),Ca.forEach(o),pr=s(Wr,": Runs RHS command only if LHS succeeds"),Wr.forEach(o),ur=f(u),je=r(u,"LI",{});var Ar=i(je);Xt=r(Ar,"CODE",{});var Oa=i(Xt);hr=s(Oa,"||"),Oa.forEach(o),mr=s(Ar,": Runs RHS command only if LHS fails"),Ar.forEach(o),Er=f(u),ge=r(u,"LI",{});var $r=i(ge);eo=r($r,"CODE",{});var ka=i(eo);vr=s(ka,";"),ka.forEach(o),br=s($r,": Runs RHS command after LHS, regardless whether it succeeds or fails"),$r.forEach(o),u.forEach(o),Zo=f(t),xe=r(t,"H2",{});var Pa=i(xe);_r=s(Pa,"Useful idioms"),Pa.forEach(o),Fo=f(t),g=r(t,"P",{});var co=i(g);Sr=s(co,"Send a signal to all jobs: "),to=r(co,"CODE",{});var Da=i(to);wr=s(Da,"kill $(jobs -p)"),Da.forEach(o),yr=s(co," or "),oo=r(co,"CODE",{});var La=i(oo);Ir=s(La,"jobs -p | xargs kill"),La.forEach(o),co.forEach(o),Ko=f(t),Re=r(t,"H2",{});var Ta=i(Re);Cr=s(Ta,"References"),Ta.forEach(o),zo=f(t),I=r(t,"UL",{});var A=i(I);lo=r(A,"LI",{});var ja=i(lo);z=r(ja,"A",{href:!0,rel:!0});var ga=i(z);Or=s(ga,"glibc docs describing signals"),ga.forEach(o),ja.forEach(o),kr=f(A),so=r(A,"LI",{});var xa=i(so);V=r(xa,"A",{href:!0,rel:!0});var Ra=i(V);Pr=s(Ra,"man 7 pages on signals"),Ra.forEach(o),xa.forEach(o),Dr=f(A),no=r(A,"LI",{});var Ha=i(no);X=r(Ha,"A",{href:!0,rel:!0});var Ga=i(X);Lr=s(Ga,"SO question on SIGTERM and SIGQUIT"),Ga.forEach(o),Ha.forEach(o),Tr=f(A),ro=r(A,"LI",{});var Ua=i(ro);ee=r(Ua,"A",{href:!0,rel:!0});var Ja=i(ee);jr=s(Ja,"SO question on disown and nohup"),Ja.forEach(o),Ua.forEach(o),A.forEach(o),this.h()},h(){j(F,"class","language-bash"),j(K,"class","language-bash"),j(z,"href","https://www.gnu.org/software/libc/manual/html_node/Standard-Signals.html"),j(z,"rel","nofollow"),j(V,"href","https://man7.org/linux/man-pages/man7/signal.7.html"),j(V,"rel","nofollow"),j(X,"href","https://stackoverflow.com/questions/4042201/how-does-sigint-relate-to-the-other-termination-signals-such-as-sigterm-sigquit"),j(X,"rel","nofollow"),j(ee,"href","https://unix.stackexchange.com/questions/3886/difference-between-nohup-disown-and"),j(ee,"rel","nofollow")},m(t,a){c(t,x,a),e(x,rl),c(t,fo,a),c(t,te,a),e(te,il),c(t,po,a),c(t,oe,a),e(oe,al),c(t,uo,a),c(t,v,a),e(v,cl),e(v,Be),e(Be,dl),e(v,fl),e(v,Me),e(Me,pl),e(v,ul),e(v,Ne),e(Ne,hl),e(v,ml),e(v,qe),e(qe,El),e(v,vl),c(t,ho,a),c(t,le,a),e(le,We),e(We,bl),c(t,mo,a),c(t,se,a),e(se,_l),c(t,Eo,a),c(t,ne,a),e(ne,Sl),c(t,vo,a),c(t,R,a),e(R,wl),e(R,Ae),e(Ae,yl),e(R,Il),c(t,bo,a),c(t,re,a),e(re,Cl),c(t,_o,a),c(t,H,a),e(H,Ol),e(H,$e),e($e,kl),e(H,Pl),c(t,So,a),c(t,ie,a),e(ie,Dl),c(t,wo,a),c(t,ae,a),e(ae,Ll),c(t,yo,a),c(t,ce,a),e(ce,Tl),c(t,Io,a),c(t,de,a),e(de,jl),c(t,Co,a),c(t,fe,a),e(fe,gl),c(t,Oo,a),c(t,h,a),e(h,Qe),e(Qe,Ye),e(Ye,xl),e(h,Rl),e(h,Ze),e(Ze,G),e(G,Hl),e(G,Fe),e(Fe,Gl),e(G,Ul),e(G,Ke),e(Ke,Jl),e(h,Bl),e(h,ze),e(ze,$),e($,Ml),e($,Ve),e(Ve,Nl),e($,ql),e(h,Wl),e(h,Xe),e(Xe,Q),e(Q,Al),e(Q,et),e(et,$l),e(Q,Ql),e(h,Yl),e(h,tt),e(tt,ot),e(ot,Zl),e(h,Fl),e(h,lt),e(lt,Y),e(Y,Kl),e(Y,st),e(st,zl),e(Y,Vl),e(h,Xl),e(h,nt),e(nt,Z),e(Z,es),e(Z,rt),e(rt,ts),e(Z,os),e(h,ls),e(h,it),e(it,at),e(at,ss),c(t,ko,a),c(t,pe,a),e(pe,ns),c(t,Po,a),c(t,m,a),e(m,rs),e(m,ct),e(ct,is),e(m,as),e(m,dt),e(dt,cs),e(m,ds),e(m,ft),e(ft,fs),e(m,ps),e(m,pt),e(pt,us),e(m,hs),e(m,ut),e(ut,ms),e(m,Es),c(t,Do,a),c(t,O,a),e(O,vs),e(O,ht),e(ht,bs),e(O,_s),e(O,mt),e(mt,Ss),e(O,ws),c(t,Lo,a),c(t,k,a),e(k,ys),e(k,Et),e(Et,Is),e(k,Cs),e(k,vt),e(vt,Os),e(k,ks),c(t,To,a),c(t,F,a),F.innerHTML=Na,c(t,jo,a),c(t,ue,a),e(ue,Ps),c(t,go,a),c(t,K,a),K.innerHTML=qa,c(t,xo,a),c(t,_,a),e(_,Ds),e(_,bt),e(bt,Ls),e(_,Ts),e(_,_t),e(_t,js),e(_,gs),e(_,St),e(St,xs),e(_,Rs),c(t,Ro,a),c(t,S,a),e(S,Hs),e(S,wt),e(wt,Gs),e(S,Us),e(S,yt),e(yt,Js),e(S,Bs),e(S,It),e(It,Ms),e(S,Ns),c(t,Ho,a),c(t,he,a),e(he,qs),c(t,Go,a),c(t,me,a),e(me,Ws),c(t,Uo,a),c(t,U,a),e(U,As),e(U,Ct),e(Ct,$s),e(U,Qs),c(t,Jo,a),c(t,Ee,a),e(Ee,Ys),c(t,Bo,a),c(t,P,a),e(P,Ot),e(Ot,Zs),e(P,Fs),e(P,kt),e(kt,Ks),e(P,zs),e(P,Pt),e(Pt,Vs),c(t,Mo,a),c(t,J,a),e(J,Xs),e(J,Dt),e(Dt,en),e(J,tn),c(t,No,a),c(t,ve,a),e(ve,on),c(t,qo,a),c(t,D,a),e(D,be),e(be,Lt),e(Lt,ln),e(be,sn),e(D,nn),e(D,_e),e(_e,Tt),e(Tt,rn),e(_e,an),e(D,cn),e(D,Se),e(Se,jt),e(jt,dn),e(Se,fn),c(t,Wo,a),c(t,w,a),e(w,pn),e(w,gt),e(gt,un),e(w,hn),e(w,xt),e(xt,mn),e(w,En),e(w,Rt),e(Rt,vn),e(w,bn),c(t,Ao,a),c(t,b,a),e(b,_n),e(b,Ht),e(Ht,Sn),e(b,wn),e(b,Gt),e(Gt,yn),e(b,In),e(b,Ut),e(Ut,Cn),e(b,On),e(b,Jt),e(Jt,kn),e(b,Pn),c(t,$o,a),c(t,y,a),e(y,Dn),e(y,Bt),e(Bt,Ln),e(y,Tn),e(y,Mt),e(Mt,jn),e(y,gn),e(y,Nt),e(Nt,xn),e(y,Rn),c(t,Qo,a),c(t,we,a),e(we,Hn),c(t,Yo,a),c(t,p,a),e(p,ye),e(ye,qt),e(qt,Gn),e(ye,Un),e(p,Jn),e(p,Ie),e(Ie,Wt),e(Wt,Bn),e(Ie,Mn),e(p,Nn),e(p,Ce),e(Ce,At),e(At,qn),e(Ce,Wn),e(p,An),e(p,Oe),e(Oe,$t),e($t,$n),e(Oe,Qn),e(p,Yn),e(p,ke),e(ke,Qt),e(Qt,Zn),e(ke,Fn),e(p,Kn),e(p,Pe),e(Pe,Yt),e(Yt,zn),e(Pe,Vn),e(p,Xn),e(p,De),e(De,Zt),e(Zt,er),e(De,tr),e(p,or),e(p,Le),e(Le,Ft),e(Ft,lr),e(Le,sr),e(p,nr),e(p,B),e(B,Kt),e(Kt,rr),e(B,ir),e(B,zt),e(zt,ar),e(B,cr),e(p,dr),e(p,Te),e(Te,Vt),e(Vt,fr),e(Te,pr),e(p,ur),e(p,je),e(je,Xt),e(Xt,hr),e(je,mr),e(p,Er),e(p,ge),e(ge,eo),e(eo,vr),e(ge,br),c(t,Zo,a),c(t,xe,a),e(xe,_r),c(t,Fo,a),c(t,g,a),e(g,Sr),e(g,to),e(to,wr),e(g,yr),e(g,oo),e(oo,Ir),c(t,Ko,a),c(t,Re,a),e(Re,Cr),c(t,zo,a),c(t,I,a),e(I,lo),e(lo,z),e(z,Or),e(I,kr),e(I,so),e(so,V),e(V,Pr),e(I,Dr),e(I,no),e(no,X),e(X,Lr),e(I,Tr),e(I,ro),e(ro,ee),e(ee,jr)},p:Qr,i:Qr,o:Qr,d(t){t&&o(x),t&&o(fo),t&&o(te),t&&o(po),t&&o(oe),t&&o(uo),t&&o(v),t&&o(ho),t&&o(le),t&&o(mo),t&&o(se),t&&o(Eo),t&&o(ne),t&&o(vo),t&&o(R),t&&o(bo),t&&o(re),t&&o(_o),t&&o(H),t&&o(So),t&&o(ie),t&&o(wo),t&&o(ae),t&&o(yo),t&&o(ce),t&&o(Io),t&&o(de),t&&o(Co),t&&o(fe),t&&o(Oo),t&&o(h),t&&o(ko),t&&o(pe),t&&o(Po),t&&o(m),t&&o(Do),t&&o(O),t&&o(Lo),t&&o(k),t&&o(To),t&&o(F),t&&o(jo),t&&o(ue),t&&o(go),t&&o(K),t&&o(xo),t&&o(_),t&&o(Ro),t&&o(S),t&&o(Ho),t&&o(he),t&&o(Go),t&&o(me),t&&o(Uo),t&&o(U),t&&o(Jo),t&&o(Ee),t&&o(Bo),t&&o(P),t&&o(Mo),t&&o(J),t&&o(No),t&&o(ve),t&&o(qo),t&&o(D),t&&o(Wo),t&&o(w),t&&o(Ao),t&&o(b),t&&o($o),t&&o(y),t&&o(Qo),t&&o(we),t&&o(Yo),t&&o(p),t&&o(Zo),t&&o(xe),t&&o(Fo),t&&o(g),t&&o(Ko),t&&o(Re),t&&o(zo),t&&o(I)}}}const Fa={title:"Managing Processes in Linux CLI",date:"2023-10-29"},{title:Ba,date:za}=Fa;class Va extends $a{constructor(x){super(),Qa(this,x,null,Za,Ya,{})}}export{Va as default,Fa as metadata};
