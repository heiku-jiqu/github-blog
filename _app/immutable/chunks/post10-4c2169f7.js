import{S as Ja,i as Ka,s as Qa,k as l,q as e,a as r,l as c,m as i,r as o,h as a,c as k,n as M,b as p,B as n,A as ca}from"./index-4cbca6b4.js";function Va(qa){let w,bs,Z,x,_s,$,T,vs,ss,f,Es,F,gs,Ps,N,xs,Ts,as,H,Hs,ns,b,Aa=`<code class="language-py">df <span class="token operator">=</span> pd<span class="token punctuation">.</span>DataFrame<span class="token punctuation">(</span><span class="token punctuation">&#123;</span>
	<span class="token string">'name'</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">,</span><span class="token string">'b'</span><span class="token punctuation">,</span><span class="token string">'c'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
	<span class="token string">'age'</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token number">25</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">,</span> <span class="token number">99</span><span class="token punctuation">]</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">)</span></code>`,ts,S,Ss,es,_,Ia='<code class="language-py">df<span class="token punctuation">[</span>df<span class="token punctuation">.</span>age <span class="token operator">&lt;=</span><span class="token number">30</span><span class="token punctuation">]</span></code>',os,C,Cs,ps,v,La=`<code class="language-py">df<span class="token punctuation">[</span><span class="token string">'new_col'</span><span class="token punctuation">]</span> <span class="token operator">=</span> df<span class="token punctuation">.</span>age <span class="token operator">+</span> <span class="token number">30</span></code>`,ls,D,Ds,cs,E,Ma=`<code class="language-py">df2 <span class="token operator">=</span> df<span class="token punctuation">[</span>df<span class="token punctuation">.</span>age <span class="token operator">&lt;=</span> <span class="token number">30</span><span class="token punctuation">]</span> <span class="token comment"># does not change df in-place?</span>
df2<span class="token punctuation">[</span><span class="token string">'new_col'</span><span class="token punctuation">]</span> <span class="token operator">=</span> df2<span class="token punctuation">.</span>age <span class="token operator">+</span> <span class="token number">30</span> <span class="token comment"># changes df2 in-place?</span></code>`,is,O,Os,us,m,Rs,U,qs,As,W,Is,Ls,rs,g,Fa=`<code class="language-py">df<span class="token punctuation">.</span>query<span class="token punctuation">(</span>
	<span class="token string">'age &lt;= 30'</span>
<span class="token punctuation">)</span><span class="token punctuation">.</span>assign<span class="token punctuation">(</span>
	new_col <span class="token operator">=</span> <span class="token keyword">lambda</span> x<span class="token punctuation">:</span> x<span class="token punctuation">[</span><span class="token string">'age'</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">20</span>
<span class="token punctuation">)</span><span class="token punctuation">.</span>query<span class="token punctuation">(</span>
	<span class="token string">'new_col >= 50'</span>
<span class="token punctuation">)</span></code>`,ks,h,Ms,B,Fs,Ns,G,Us,Ws,ds,y,Bs,j,Gs,js,fs,u,zs,z,Js,Ks,J,Qs,Vs,K,Xs,Ys,Q,Zs,$s,V,sa,aa,X,na,ta,Y,ea,oa,ms,R,pa,hs,q,la,ws,P,Na=`<code class="language-python">df <span class="token operator">=</span> pd<span class="token punctuation">.</span>DataFrame<span class="token punctuation">(</span><span class="token punctuation">&#123;</span>
	<span class="token string">'name'</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">,</span><span class="token string">'b'</span><span class="token punctuation">,</span><span class="token string">'c'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
	<span class="token string">'age'</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token number">25</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">,</span> <span class="token number">99</span><span class="token punctuation">]</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">)</span>

<span class="token keyword">def</span> <span class="token function">to_uppercase</span><span class="token punctuation">(</span>col_name<span class="token punctuation">)</span><span class="token punctuation">:</span>
	<span class="token keyword">return</span> <span class="token keyword">lambda</span> dataframe<span class="token punctuation">:</span> dataframe<span class="token punctuation">[</span>col_name<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token builtin">map</span><span class="token punctuation">(</span><span class="token keyword">lambda</span> x<span class="token punctuation">:</span> <span class="token string">'Using element wise map: '</span> <span class="token operator">+</span> x<span class="token punctuation">.</span>upper<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token keyword">def</span> <span class="token function">series_transform_string</span><span class="token punctuation">(</span>x<span class="token punctuation">:</span> pd<span class="token punctuation">.</span>Series<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> pd<span class="token punctuation">.</span>Series<span class="token punctuation">:</span>
    <span class="token keyword">return</span> <span class="token string">'Using vectorised pipe: '</span> <span class="token operator">+</span> x<span class="token punctuation">.</span><span class="token builtin">str</span><span class="token punctuation">.</span>upper<span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token keyword">def</span> <span class="token function">to_uppercase2</span><span class="token punctuation">(</span>col_name<span class="token punctuation">)</span><span class="token punctuation">:</span>
	<span class="token keyword">return</span> <span class="token keyword">lambda</span> dataframe<span class="token punctuation">:</span> dataframe<span class="token punctuation">[</span>col_name<span class="token punctuation">]</span><span class="token punctuation">.</span>pipe<span class="token punctuation">(</span>series_transform_string<span class="token punctuation">)</span>

df<span class="token punctuation">.</span>assign<span class="token punctuation">(</span>
	more_than_seventy <span class="token operator">=</span> <span class="token keyword">lambda</span> d<span class="token punctuation">:</span> d<span class="token punctuation">[</span><span class="token string">'age'</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token builtin">map</span><span class="token punctuation">(</span><span class="token keyword">lambda</span> age<span class="token punctuation">:</span> <span class="token boolean">True</span> <span class="token keyword">if</span> age <span class="token operator">></span> <span class="token number">70</span> <span class="token keyword">else</span> <span class="token boolean">False</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
	uppercase_name <span class="token operator">=</span> to_uppercase<span class="token punctuation">(</span><span class="token string">'name'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    another_upper <span class="token operator">=</span> to_uppercase2<span class="token punctuation">(</span><span class="token string">'name'</span><span class="token punctuation">)</span>
<span class="token punctuation">)</span></code>`;return{c(){w=l("h1"),bs=e(Ra),Z=r(),x=l("p"),_s=e("In this post, I explore possible ways to write Pandas code in hopes of makign Pandas code more readable, composable, reusable, and testable."),$=r(),T=l("h2"),vs=e("Motivation"),ss=r(),f=l("p"),Es=e("After using R\u2019s "),F=l("code"),gs=e("dplyr"),Ps=e(" (and the entire "),N=l("code"),xs=e("tidyverse"),Ts=e(` ecosystem) to manipulate dataframes for awhile, Panda\u2019s API feels clunky in comparison.
The main issue seems to be difficulty in chaining and composing operations.
This tends to cause Pandas code to go against good software design principles, because it is difficult to break down larger chain of operations and also difficult to stitch smaller operations together.
This has an added effect of making tests hard to write, as user written Pandas functions are often doing a lot of things at once.`),as=r(),H=l("h2"),Hs=e("Concrete Example of the Issue"),ns=r(),b=l("pre"),ts=r(),S=l("p"),Ss=e("A common way to filter the rows of dataframe is:"),es=r(),_=l("pre"),os=r(),C=l("p"),Cs=e("And a common way to assign a new column to the dataframe is:"),ps=r(),v=l("pre"),ls=r(),D=l("p"),Ds=e(`Now with the above two operations, how does one chain those two simple operations together?
We will probably have to keep assigning intermediate dataframe variables, which gets clunky after awhile:`),cs=r(),E=l("pre"),is=r(),O=l("h2"),Os=e(".assign and .query"),us=r(),m=l("p"),Rs=e("A more chainable way to do filters and add calculated columns is to use "),U=l("code"),qs=e(".query()"),As=e(" and "),W=l("code"),Is=e(".assign()"),Ls=e(" methods:"),rs=r(),g=l("pre"),ks=r(),h=l("p"),Ms=e(`Even though this is better, there are still some drawbacks.
The first is `),B=l("code"),Fs=e(".query()"),Ns=e(` uses a query string and not native python code,
which means you lose all IDE auto complete capabilities `),G=l("em"),Us=e("(\u2018what columns do my dataframe have again?\u2018)"),Ws=e("."),ds=r(),y=l("p"),Bs=e("The second is that using "),j=l("code"),Gs=e("assign"),js=e(` fixes the column names that the lambda function operates on,
unless you introduce another layer of abstraction to parameterise the lambda function.
This second point is important when you want to reuse this function across different dataframes.
This is seems to be caused by the next point.`),fs=r(),u=l("p"),zs=e("The third point is the un-intuitiveness of the LHS and RHS of the expressions in "),z=l("code"),Js=e(".assign()"),Ks=e(`\u2019s arguments.
One would expect that since we are assigning a new `),J=l("strong"),Qs=e("column"),Vs=e(" (i.e. a "),K=l("code"),Xs=e("Series"),Ys=e(") called "),Q=l("code"),Zs=e("new_col"),$s=e(" on the LHS, the RHS\u2019 lambda input(s) should be of type "),V=l("code"),sa=e("Series"),aa=e(" as well. However this is not the case as the lambda function takes in a "),X=l("code"),na=e("DataFrame"),ta=e(" as input, and expects a "),Y=l("code"),ea=e("Series"),oa=e(" as output."),ms=r(),R=l("h1"),pa=e(".apply, .applymap, .map, .pipe ???"),hs=r(),q=l("h1"),la=e("Code examples"),ws=r(),P=l("pre"),this.h()},l(s){w=c(s,"H1",{});var t=i(w);bs=o(t,Ra),t.forEach(a),Z=k(s),x=c(s,"P",{});var ia=i(x);_s=o(ia,"In this post, I explore possible ways to write Pandas code in hopes of makign Pandas code more readable, composable, reusable, and testable."),ia.forEach(a),$=k(s),T=c(s,"H2",{});var ua=i(T);vs=o(ua,"Motivation"),ua.forEach(a),ss=k(s),f=c(s,"P",{});var A=i(f);Es=o(A,"After using R\u2019s "),F=c(A,"CODE",{});var ra=i(F);gs=o(ra,"dplyr"),ra.forEach(a),Ps=o(A," (and the entire "),N=c(A,"CODE",{});var ka=i(N);xs=o(ka,"tidyverse"),ka.forEach(a),Ts=o(A,` ecosystem) to manipulate dataframes for awhile, Panda\u2019s API feels clunky in comparison.
The main issue seems to be difficulty in chaining and composing operations.
This tends to cause Pandas code to go against good software design principles, because it is difficult to break down larger chain of operations and also difficult to stitch smaller operations together.
This has an added effect of making tests hard to write, as user written Pandas functions are often doing a lot of things at once.`),A.forEach(a),as=k(s),H=c(s,"H2",{});var da=i(H);Hs=o(da,"Concrete Example of the Issue"),da.forEach(a),ns=k(s),b=c(s,"PRE",{class:!0});var Ua=i(b);Ua.forEach(a),ts=k(s),S=c(s,"P",{});var fa=i(S);Ss=o(fa,"A common way to filter the rows of dataframe is:"),fa.forEach(a),es=k(s),_=c(s,"PRE",{class:!0});var Wa=i(_);Wa.forEach(a),os=k(s),C=c(s,"P",{});var ma=i(C);Cs=o(ma,"And a common way to assign a new column to the dataframe is:"),ma.forEach(a),ps=k(s),v=c(s,"PRE",{class:!0});var Ba=i(v);Ba.forEach(a),ls=k(s),D=c(s,"P",{});var ha=i(D);Ds=o(ha,`Now with the above two operations, how does one chain those two simple operations together?
We will probably have to keep assigning intermediate dataframe variables, which gets clunky after awhile:`),ha.forEach(a),cs=k(s),E=c(s,"PRE",{class:!0});var Ga=i(E);Ga.forEach(a),is=k(s),O=c(s,"H2",{});var wa=i(O);Os=o(wa,".assign and .query"),wa.forEach(a),us=k(s),m=c(s,"P",{});var I=i(m);Rs=o(I,"A more chainable way to do filters and add calculated columns is to use "),U=c(I,"CODE",{});var ya=i(U);qs=o(ya,".query()"),ya.forEach(a),As=o(I," and "),W=c(I,"CODE",{});var ba=i(W);Is=o(ba,".assign()"),ba.forEach(a),Ls=o(I," methods:"),I.forEach(a),rs=k(s),g=c(s,"PRE",{class:!0});var ja=i(g);ja.forEach(a),ks=k(s),h=c(s,"P",{});var L=i(h);Ms=o(L,`Even though this is better, there are still some drawbacks.
The first is `),B=c(L,"CODE",{});var _a=i(B);Fs=o(_a,".query()"),_a.forEach(a),Ns=o(L,` uses a query string and not native python code,
which means you lose all IDE auto complete capabilities `),G=c(L,"EM",{});var va=i(G);Us=o(va,"(\u2018what columns do my dataframe have again?\u2018)"),va.forEach(a),Ws=o(L,"."),L.forEach(a),ds=k(s),y=c(s,"P",{});var ys=i(y);Bs=o(ys,"The second is that using "),j=c(ys,"CODE",{});var Ea=i(j);Gs=o(Ea,"assign"),Ea.forEach(a),js=o(ys,` fixes the column names that the lambda function operates on,
unless you introduce another layer of abstraction to parameterise the lambda function.
This second point is important when you want to reuse this function across different dataframes.
This is seems to be caused by the next point.`),ys.forEach(a),fs=k(s),u=c(s,"P",{});var d=i(u);zs=o(d,"The third point is the un-intuitiveness of the LHS and RHS of the expressions in "),z=c(d,"CODE",{});var ga=i(z);Js=o(ga,".assign()"),ga.forEach(a),Ks=o(d,`\u2019s arguments.
One would expect that since we are assigning a new `),J=c(d,"STRONG",{});var Pa=i(J);Qs=o(Pa,"column"),Pa.forEach(a),Vs=o(d," (i.e. a "),K=c(d,"CODE",{});var xa=i(K);Xs=o(xa,"Series"),xa.forEach(a),Ys=o(d,") called "),Q=c(d,"CODE",{});var Ta=i(Q);Zs=o(Ta,"new_col"),Ta.forEach(a),$s=o(d," on the LHS, the RHS\u2019 lambda input(s) should be of type "),V=c(d,"CODE",{});var Ha=i(V);sa=o(Ha,"Series"),Ha.forEach(a),aa=o(d," as well. However this is not the case as the lambda function takes in a "),X=c(d,"CODE",{});var Sa=i(X);na=o(Sa,"DataFrame"),Sa.forEach(a),ta=o(d," as input, and expects a "),Y=c(d,"CODE",{});var Ca=i(Y);ea=o(Ca,"Series"),Ca.forEach(a),oa=o(d," as output."),d.forEach(a),ms=k(s),R=c(s,"H1",{});var Da=i(R);pa=o(Da,".apply, .applymap, .map, .pipe ???"),Da.forEach(a),hs=k(s),q=c(s,"H1",{});var Oa=i(q);la=o(Oa,"Code examples"),Oa.forEach(a),ws=k(s),P=c(s,"PRE",{class:!0});var za=i(P);za.forEach(a),this.h()},h(){M(b,"class","language-py"),M(_,"class","language-py"),M(v,"class","language-py"),M(E,"class","language-py"),M(g,"class","language-py"),M(P,"class","language-python")},m(s,t){p(s,w,t),n(w,bs),p(s,Z,t),p(s,x,t),n(x,_s),p(s,$,t),p(s,T,t),n(T,vs),p(s,ss,t),p(s,f,t),n(f,Es),n(f,F),n(F,gs),n(f,Ps),n(f,N),n(N,xs),n(f,Ts),p(s,as,t),p(s,H,t),n(H,Hs),p(s,ns,t),p(s,b,t),b.innerHTML=Aa,p(s,ts,t),p(s,S,t),n(S,Ss),p(s,es,t),p(s,_,t),_.innerHTML=Ia,p(s,os,t),p(s,C,t),n(C,Cs),p(s,ps,t),p(s,v,t),v.innerHTML=La,p(s,ls,t),p(s,D,t),n(D,Ds),p(s,cs,t),p(s,E,t),E.innerHTML=Ma,p(s,is,t),p(s,O,t),n(O,Os),p(s,us,t),p(s,m,t),n(m,Rs),n(m,U),n(U,qs),n(m,As),n(m,W),n(W,Is),n(m,Ls),p(s,rs,t),p(s,g,t),g.innerHTML=Fa,p(s,ks,t),p(s,h,t),n(h,Ms),n(h,B),n(B,Fs),n(h,Ns),n(h,G),n(G,Us),n(h,Ws),p(s,ds,t),p(s,y,t),n(y,Bs),n(y,j),n(j,Gs),n(y,js),p(s,fs,t),p(s,u,t),n(u,zs),n(u,z),n(z,Js),n(u,Ks),n(u,J),n(J,Qs),n(u,Vs),n(u,K),n(K,Xs),n(u,Ys),n(u,Q),n(Q,Zs),n(u,$s),n(u,V),n(V,sa),n(u,aa),n(u,X),n(X,na),n(u,ta),n(u,Y),n(Y,ea),n(u,oa),p(s,ms,t),p(s,R,t),n(R,pa),p(s,hs,t),p(s,q,t),n(q,la),p(s,ws,t),p(s,P,t),P.innerHTML=Na},p:ca,i:ca,o:ca,d(s){s&&a(w),s&&a(Z),s&&a(x),s&&a($),s&&a(T),s&&a(ss),s&&a(f),s&&a(as),s&&a(H),s&&a(ns),s&&a(b),s&&a(ts),s&&a(S),s&&a(es),s&&a(_),s&&a(os),s&&a(C),s&&a(ps),s&&a(v),s&&a(ls),s&&a(D),s&&a(cs),s&&a(E),s&&a(is),s&&a(O),s&&a(us),s&&a(m),s&&a(rs),s&&a(g),s&&a(ks),s&&a(h),s&&a(ds),s&&a(y),s&&a(fs),s&&a(u),s&&a(ms),s&&a(R),s&&a(hs),s&&a(q),s&&a(ws),s&&a(P)}}}const Xa={title:"Composable Pandas (or Not)",date:"2023-03-03"},{title:Ra,date:Za}=Xa;class $a extends Ja{constructor(w){super(),Ka(this,w,null,Va,Qa,{})}}export{$a as default,Xa as metadata};
