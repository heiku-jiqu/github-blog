import{S as Be,i as Le,s as Ue,k as r,q as n,a as E,l,m as s,r as i,h as o,c as _,n as ze,b as f,B as t,A as Oe}from"./index-30b72abd.js";function Fe(Ie){let m,U,R,w,z,q,p,F,M,K,N,y,Q,W,I,v,Z,x,$,g,P,ee,te,J,C,oe,k,a,ne,S,ie,re,T,le,se,Y,ae,ce,G,de,fe,V,pe,ve,b,he,me,X,ue,Ee,B,u,Je=`<code class="language-undefined">// Create a new DOMPoint object with clientX and clientY as its x and y coordinate
let p = DOMPoint(event.clientX, event.clientY)

// Create a DOMMatrix that transforms screen coordinates to SVG coordinates
let transform_matrix = svg.getScreenCTM().inverse()

// Use the matrix in DOMPoint.matrixTransform()
let new_point = p.matrixTransform(transform_matrix)

console.log(new_point.x, new_point.y)</code>`,L,h,H,_e,we,j,Ce,De;return{c(){m=r("h1"),U=n(qe),R=E(),w=r("h2"),z=n("Motivation"),q=E(),p=r("p"),F=n("Javascript DOM events lets you capture mouse position relative to top left corner of your viewport through "),M=r("code"),K=n("clientX"),N=n("/"),y=r("code"),Q=n("clientY"),W=n(" event properties."),I=E(),v=r("p"),Z=n("If you are drawing SVGs and need to position SVG elements in on the mouse pointer, you will need to convert the coordinates given by "),x=r("code"),$=n("clientX"),g=n("/"),P=r("code"),ee=n("clientY"),te=n(" into the SVG\u2019s coordinates."),J=E(),C=r("h2"),oe=n("Solution"),k=E(),a=r("p"),ne=n("You will need 3 things: - The "),S=r("code"),ie=n("clientX"),re=n(" and "),T=r("code"),le=n("clientY"),se=n(" properties from the "),Y=r("code"),ae=n("MouseEvent"),ce=n(" - A "),G=r("code"),de=n("DOMPoint"),fe=n(" object created using "),V=r("code"),pe=n("DOMPoint()"),ve=n(", or "),b=r("code"),he=n("SVGPoint"),me=n(" object - Reference to the "),X=r("code"),ue=n("<svg>"),Ee=n(" node"),B=E(),u=r("pre"),L=E(),h=r("p"),H=r("code"),_e=n("CTM"),we=n(" stands for Current Transformation Matrix, and maps the local coordinate system into the viewport coordinate system. However, since we want the opposite, we have to call "),j=r("code"),Ce=n(".inverse()"),De=n(" to inverse the matrix to get the opposite effect."),this.h()},l(e){m=l(e,"H1",{});var c=s(m);U=i(c,qe),c.forEach(o),R=_(e),w=l(e,"H2",{});var Me=s(w);z=i(Me,"Motivation"),Me.forEach(o),q=_(e),p=l(e,"P",{});var D=s(p);F=i(D,"Javascript DOM events lets you capture mouse position relative to top left corner of your viewport through "),M=l(D,"CODE",{});var ye=s(M);K=i(ye,"clientX"),ye.forEach(o),N=i(D,"/"),y=l(D,"CODE",{});var xe=s(y);Q=i(xe,"clientY"),xe.forEach(o),W=i(D," event properties."),D.forEach(o),I=_(e),v=l(e,"P",{});var O=s(v);Z=i(O,"If you are drawing SVGs and need to position SVG elements in on the mouse pointer, you will need to convert the coordinates given by "),x=l(O,"CODE",{});var Pe=s(x);$=i(Pe,"clientX"),Pe.forEach(o),g=i(O,"/"),P=l(O,"CODE",{});var Se=s(P);ee=i(Se,"clientY"),Se.forEach(o),te=i(O," into the SVG\u2019s coordinates."),O.forEach(o),J=_(e),C=l(e,"H2",{});var Te=s(C);oe=i(Te,"Solution"),Te.forEach(o),k=_(e),a=l(e,"P",{});var d=s(a);ne=i(d,"You will need 3 things: - The "),S=l(d,"CODE",{});var Ye=s(S);ie=i(Ye,"clientX"),Ye.forEach(o),re=i(d," and "),T=l(d,"CODE",{});var Ge=s(T);le=i(Ge,"clientY"),Ge.forEach(o),se=i(d," properties from the "),Y=l(d,"CODE",{});var Ve=s(Y);ae=i(Ve,"MouseEvent"),Ve.forEach(o),ce=i(d," - A "),G=l(d,"CODE",{});var be=s(G);de=i(be,"DOMPoint"),be.forEach(o),fe=i(d," object created using "),V=l(d,"CODE",{});var Xe=s(V);pe=i(Xe,"DOMPoint()"),Xe.forEach(o),ve=i(d,", or "),b=l(d,"CODE",{});var He=s(b);he=i(He,"SVGPoint"),He.forEach(o),me=i(d," object - Reference to the "),X=l(d,"CODE",{});var je=s(X);ue=i(je,"<svg>"),je.forEach(o),Ee=i(d," node"),d.forEach(o),B=_(e),u=l(e,"PRE",{class:!0});var ke=s(u);ke.forEach(o),L=_(e),h=l(e,"P",{});var A=s(h);H=l(A,"CODE",{});var Ae=s(H);_e=i(Ae,"CTM"),Ae.forEach(o),we=i(A," stands for Current Transformation Matrix, and maps the local coordinate system into the viewport coordinate system. However, since we want the opposite, we have to call "),j=l(A,"CODE",{});var Re=s(j);Ce=i(Re,".inverse()"),Re.forEach(o),De=i(A," to inverse the matrix to get the opposite effect."),A.forEach(o),this.h()},h(){ze(u,"class","language-undefined")},m(e,c){f(e,m,c),t(m,U),f(e,R,c),f(e,w,c),t(w,z),f(e,q,c),f(e,p,c),t(p,F),t(p,M),t(M,K),t(p,N),t(p,y),t(y,Q),t(p,W),f(e,I,c),f(e,v,c),t(v,Z),t(v,x),t(x,$),t(v,g),t(v,P),t(P,ee),t(v,te),f(e,J,c),f(e,C,c),t(C,oe),f(e,k,c),f(e,a,c),t(a,ne),t(a,S),t(S,ie),t(a,re),t(a,T),t(T,le),t(a,se),t(a,Y),t(Y,ae),t(a,ce),t(a,G),t(G,de),t(a,fe),t(a,V),t(V,pe),t(a,ve),t(a,b),t(b,he),t(a,me),t(a,X),t(X,ue),t(a,Ee),f(e,B,c),f(e,u,c),u.innerHTML=Je,f(e,L,c),f(e,h,c),t(h,H),t(H,_e),t(h,we),t(h,j),t(j,Ce),t(h,De)},p:Oe,i:Oe,o:Oe,d(e){e&&o(m),e&&o(R),e&&o(w),e&&o(q),e&&o(p),e&&o(I),e&&o(v),e&&o(J),e&&o(C),e&&o(k),e&&o(a),e&&o(B),e&&o(u),e&&o(L),e&&o(h)}}}const Ke={title:"Converting Coordinates to Different Coordinate System",date:"2022-11-11"},{title:qe,date:Qe}=Ke;class We extends Be{constructor(m){super(),Le(this,m,null,Fe,Ue,{})}}export{We as default,Ke as metadata};
