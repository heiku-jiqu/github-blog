import{S as Un,i as Hn,s as Wn,k as o,q as n,a as h,l,m as s,r as i,h as t,c,b as d,B as e,A as Ba}from"./index-39c5cc75.js";function Vn(qn){let T,et,Oe,P,tt,je,q,at,Pe,U,nt,qe,m,it,X,ot,lt,Y,st,rt,Z,ht,ct,$,dt,ft,ee,mt,ut,Ue,H,pt,He,w,C,gt,te,vt,Et,wt,ae,bt,_t,ne,yt,We,W,St,Ve,V,Tt,Ae,g,k,Lt,ie,It,Ct,kt,x,xt,oe,Mt,Ft,Dt,le,Ot,jt,A,Pt,se,re,qt,Be,B,Ut,Ne,L,he,Ht,Wt,ce,Vt,Ge,N,At,Re,u,G,Bt,M,de,Nt,Gt,fe,Rt,zt,R,Jt,F,me,Kt,Qt,ue,pe,Xt,Yt,D,Zt,ge,$t,ea,ta,f,aa,ve,na,ia,Ee,oa,la,we,sa,ra,be,ha,ca,_e,da,fa,ye,ma,ua,O,Se,pa,ga,Te,va,Ea,b,wa,Le,ba,_a,Ie,ya,Sa,_,y,Ta,Ce,La,Ia,ke,Ca,ka,xa,xe,Ma,Fa,Me,Da,Oa,S,ja,Fe,Pa,qa,De,Ua,Ha;return{c(){T=o("h1"),et=n(Pn),Oe=h(),P=o("h2"),tt=n("Background"),je=h(),q=o("p"),at=n("This post walks through how to go about implementing Finite State Machine."),Pe=h(),U=o("h2"),nt=n("What is Finite State Machine"),qe=h(),m=o("p"),it=n("Finite State Machine (aka State Machine, aka State Design Pattern) is useful pattern in programming to translate/model real world in your program where the "),X=o("em"),ot=n("thing"),lt=n(` you\u2019re trying to model goes through state transitions and behaves differently in its state.
As the name would suggest, the `),Y=o("em"),st=n("thing"),rt=n(` has a finite number of states that it can exist in.
The state is also `),Z=o("em"),ht=n("internal"),ct=n(" to the "),$=o("em"),dt=n("thing"),ft=n(", i.e. not visible to clients/users interacting with the "),ee=o("em"),mt=n("thing"),ut=n("."),Ue=h(),H=o("p"),pt=n(`We come across this type of scenario a lot in the real world.
Most control interface (e.g. remote control, media player controls, vending machine controls) can be thought of in Finite State Machine manner.`),He=h(),w=o("ul"),C=o("li"),gt=n("For remote control, pressing the \u201Cup\u201D button could mean changing channel, or it could mean navigating the settings menu, depending on what "),te=o("em"),vt=n("state"),Et=n(" the TV is in."),wt=h(),ae=o("li"),bt=n("For media player, pressing the \u201Cplay/pause\u201D button could mean starting playback if no music is playing, or pausing if music is already playing."),_t=h(),ne=o("li"),yt=n("For vending machine, pressing the dispense drink no. 1 button could dispense drink no. 1 if there is enough credits, or do nothing if there is not enough credits."),We=h(),W=o("h2"),St=n("State Design Pattern"),Ve=h(),V=o("p"),Tt=n(`Usually it is quite intuitive to know when you need to program a state machine.
The key characteristics of a state machine problem are the following:`),Ae=h(),g=o("ul"),k=o("li"),Lt=n("There are a number of states that the "),ie=o("em"),It=n("thing"),Ct=n(" can exist in"),kt=h(),x=o("li"),xt=n("The "),oe=o("em"),Mt=n("thing"),Ft=n(" behaves differently based on what state it is in"),Dt=h(),le=o("li"),Ot=n("The different states may/may not transition to each other depending on what state it is currently in, and the different rules that apply for different states."),jt=h(),A=o("li"),Pt=n("Interactions with different states are mostly similar"),se=o("ul"),re=o("li"),qt=n("In remote control example, no matter what state the TV is in, we always interact with up/down/left/right buttons etc."),Be=h(),B=o("p"),Ut=n(`In addition, let\u2019s say you are not designing from the ground up, but refactoring.
Then below are the code smells that indicate a state design pattern might be good:`),Ne=h(),L=o("ul"),he=o("li"),Ht=n("There are a lot of conditionals to change behaviour based on the object\u2019s current values."),Wt=h(),ce=o("li"),Vt=n("When the conditionals/behaviour of each state changes frequently."),Ge=h(),N=o("h2"),At=n("How to implement"),Re=h(),u=o("ol"),G=o("li"),Bt=n("Map out the state transition diagram"),M=o("ol"),de=o("li"),Nt=n("Draw all the states that your thing can exist in as nodes"),Gt=h(),fe=o("li"),Rt=n("For each node, draw and label all the transitions that can happen from this state to another state; these are the outgoing edges."),zt=h(),R=o("li"),Jt=n("Sanity check: are the edge labels (state transition names) similar across all nodes?"),F=o("ul"),me=o("li"),Kt=n("If each node has a unique set of transition names and don\u2019t overlap with other node\u2019s transition names, maybe this pattern is not suited, or you\u2019re thinking in the wrong abstraction!"),Qt=h(),ue=o("li"),pe=o("strong"),Xt=n("Think of edge labels as how a user/client would interact with your thing, not how the internal state will change."),Yt=h(),D=o("li"),Zt=n("Create a "),ge=o("code"),$t=n("State"),ea=n(" interface that has methods for all the unique state transitions."),ta=h(),f=o("li"),aa=n("Create a "),ve=o("code"),na=n("Context"),ia=n(" object that has a field pointing to a concrete state, and a method called "),Ee=o("code"),oa=n("changeState(newState)"),la=n(" that changes "),we=o("code"),sa=n("Context"),ra=n("\u2019s internal concrete state to "),be=o("code"),ha=n("newState"),ca=n(" when called. This "),_e=o("code"),da=n("Context"),fa=n(" object also implements "),ye=o("code"),ma=n("State"),ua=n(" interface, but all the methods will be forwarded/delegated to the internal concrete state."),O=o("ul"),Se=o("li"),pa=n("This object is what users/clients will interact with."),ga=h(),Te=o("li"),va=n("The state of this object changes by changing the internal concrete state field."),Ea=h(),b=o("li"),wa=n("For each node in your state diagram, create a concrete class/type that implements the "),Le=o("code"),ba=n("State"),_a=n(" interface, and also has a field pointing to the "),Ie=o("code"),ya=n("Context"),Sa=n(" object."),_=o("ul"),y=o("li"),Ta=n("Each concrete state\u2019s implementation of the "),Ce=o("code"),La=n("State"),Ia=n(" interface can then have its own isolated business logic and behaviour and do "),ke=o("code"),Ca=n("Context.changeState(newState)"),ka=n(" when appropriate."),xa=h(),xe=o("li"),Ma=n("This means concrete states are aware of each other."),Fa=h(),Me=o("li"),Da=n("Not all methods in all states need to initiate state transition, or even do anything. For example, in vending machine no credit state, pressing the \u201Cdispense drink\u201D button should do nothing!"),Oa=h(),S=o("li"),ja=n("To use, create a "),Fe=o("code"),Pa=n("Context"),qa=n(" object that initialises with an initial concrete state. Then call the "),De=o("code"),Ua=n("State"),Ha=n(" interface methods as needed.")},l(a){T=l(a,"H1",{});var r=s(T);et=i(r,Pn),r.forEach(t),Oe=c(a),P=l(a,"H2",{});var Na=s(P);tt=i(Na,"Background"),Na.forEach(t),je=c(a),q=l(a,"P",{});var Ga=s(q);at=i(Ga,"This post walks through how to go about implementing Finite State Machine."),Ga.forEach(t),Pe=c(a),U=l(a,"H2",{});var Ra=s(U);nt=i(Ra,"What is Finite State Machine"),Ra.forEach(t),qe=c(a),m=l(a,"P",{});var v=s(m);it=i(v,"Finite State Machine (aka State Machine, aka State Design Pattern) is useful pattern in programming to translate/model real world in your program where the "),X=l(v,"EM",{});var za=s(X);ot=i(za,"thing"),za.forEach(t),lt=i(v,` you\u2019re trying to model goes through state transitions and behaves differently in its state.
As the name would suggest, the `),Y=l(v,"EM",{});var Ja=s(Y);st=i(Ja,"thing"),Ja.forEach(t),rt=i(v,` has a finite number of states that it can exist in.
The state is also `),Z=l(v,"EM",{});var Ka=s(Z);ht=i(Ka,"internal"),Ka.forEach(t),ct=i(v," to the "),$=l(v,"EM",{});var Qa=s($);dt=i(Qa,"thing"),Qa.forEach(t),ft=i(v,", i.e. not visible to clients/users interacting with the "),ee=l(v,"EM",{});var Xa=s(ee);mt=i(Xa,"thing"),Xa.forEach(t),ut=i(v,"."),v.forEach(t),Ue=c(a),H=l(a,"P",{});var Ya=s(H);pt=i(Ya,`We come across this type of scenario a lot in the real world.
Most control interface (e.g. remote control, media player controls, vending machine controls) can be thought of in Finite State Machine manner.`),Ya.forEach(t),He=c(a),w=l(a,"UL",{});var z=s(w);C=l(z,"LI",{});var ze=s(C);gt=i(ze,"For remote control, pressing the \u201Cup\u201D button could mean changing channel, or it could mean navigating the settings menu, depending on what "),te=l(ze,"EM",{});var Za=s(te);vt=i(Za,"state"),Za.forEach(t),Et=i(ze," the TV is in."),ze.forEach(t),wt=c(z),ae=l(z,"LI",{});var $a=s(ae);bt=i($a,"For media player, pressing the \u201Cplay/pause\u201D button could mean starting playback if no music is playing, or pausing if music is already playing."),$a.forEach(t),_t=c(z),ne=l(z,"LI",{});var en=s(ne);yt=i(en,"For vending machine, pressing the dispense drink no. 1 button could dispense drink no. 1 if there is enough credits, or do nothing if there is not enough credits."),en.forEach(t),z.forEach(t),We=c(a),W=l(a,"H2",{});var tn=s(W);St=i(tn,"State Design Pattern"),tn.forEach(t),Ve=c(a),V=l(a,"P",{});var an=s(V);Tt=i(an,`Usually it is quite intuitive to know when you need to program a state machine.
The key characteristics of a state machine problem are the following:`),an.forEach(t),Ae=c(a),g=l(a,"UL",{});var I=s(g);k=l(I,"LI",{});var Je=s(k);Lt=i(Je,"There are a number of states that the "),ie=l(Je,"EM",{});var nn=s(ie);It=i(nn,"thing"),nn.forEach(t),Ct=i(Je," can exist in"),Je.forEach(t),kt=c(I),x=l(I,"LI",{});var Ke=s(x);xt=i(Ke,"The "),oe=l(Ke,"EM",{});var on=s(oe);Mt=i(on,"thing"),on.forEach(t),Ft=i(Ke," behaves differently based on what state it is in"),Ke.forEach(t),Dt=c(I),le=l(I,"LI",{});var ln=s(le);Ot=i(ln,"The different states may/may not transition to each other depending on what state it is currently in, and the different rules that apply for different states."),ln.forEach(t),jt=c(I),A=l(I,"LI",{});var Wa=s(A);Pt=i(Wa,"Interactions with different states are mostly similar"),se=l(Wa,"UL",{});var sn=s(se);re=l(sn,"LI",{});var rn=s(re);qt=i(rn,"In remote control example, no matter what state the TV is in, we always interact with up/down/left/right buttons etc."),rn.forEach(t),sn.forEach(t),Wa.forEach(t),I.forEach(t),Be=c(a),B=l(a,"P",{});var hn=s(B);Ut=i(hn,`In addition, let\u2019s say you are not designing from the ground up, but refactoring.
Then below are the code smells that indicate a state design pattern might be good:`),hn.forEach(t),Ne=c(a),L=l(a,"UL",{});var Qe=s(L);he=l(Qe,"LI",{});var cn=s(he);Ht=i(cn,"There are a lot of conditionals to change behaviour based on the object\u2019s current values."),cn.forEach(t),Wt=c(Qe),ce=l(Qe,"LI",{});var dn=s(ce);Vt=i(dn,"When the conditionals/behaviour of each state changes frequently."),dn.forEach(t),Qe.forEach(t),Ge=c(a),N=l(a,"H2",{});var fn=s(N);At=i(fn,"How to implement"),fn.forEach(t),Re=c(a),u=l(a,"OL",{});var E=s(u);G=l(E,"LI",{});var Va=s(G);Bt=i(Va,"Map out the state transition diagram"),M=l(Va,"OL",{});var Xe=s(M);de=l(Xe,"LI",{});var mn=s(de);Nt=i(mn,"Draw all the states that your thing can exist in as nodes"),mn.forEach(t),Gt=c(Xe),fe=l(Xe,"LI",{});var un=s(fe);Rt=i(un,"For each node, draw and label all the transitions that can happen from this state to another state; these are the outgoing edges."),un.forEach(t),Xe.forEach(t),Va.forEach(t),zt=c(E),R=l(E,"LI",{});var Aa=s(R);Jt=i(Aa,"Sanity check: are the edge labels (state transition names) similar across all nodes?"),F=l(Aa,"UL",{});var Ye=s(F);me=l(Ye,"LI",{});var pn=s(me);Kt=i(pn,"If each node has a unique set of transition names and don\u2019t overlap with other node\u2019s transition names, maybe this pattern is not suited, or you\u2019re thinking in the wrong abstraction!"),pn.forEach(t),Qt=c(Ye),ue=l(Ye,"LI",{});var gn=s(ue);pe=l(gn,"STRONG",{});var vn=s(pe);Xt=i(vn,"Think of edge labels as how a user/client would interact with your thing, not how the internal state will change."),vn.forEach(t),gn.forEach(t),Ye.forEach(t),Aa.forEach(t),Yt=c(E),D=l(E,"LI",{});var Ze=s(D);Zt=i(Ze,"Create a "),ge=l(Ze,"CODE",{});var En=s(ge);$t=i(En,"State"),En.forEach(t),ea=i(Ze," interface that has methods for all the unique state transitions."),Ze.forEach(t),ta=c(E),f=l(E,"LI",{});var p=s(f);aa=i(p,"Create a "),ve=l(p,"CODE",{});var wn=s(ve);na=i(wn,"Context"),wn.forEach(t),ia=i(p," object that has a field pointing to a concrete state, and a method called "),Ee=l(p,"CODE",{});var bn=s(Ee);oa=i(bn,"changeState(newState)"),bn.forEach(t),la=i(p," that changes "),we=l(p,"CODE",{});var _n=s(we);sa=i(_n,"Context"),_n.forEach(t),ra=i(p,"\u2019s internal concrete state to "),be=l(p,"CODE",{});var yn=s(be);ha=i(yn,"newState"),yn.forEach(t),ca=i(p," when called. This "),_e=l(p,"CODE",{});var Sn=s(_e);da=i(Sn,"Context"),Sn.forEach(t),fa=i(p," object also implements "),ye=l(p,"CODE",{});var Tn=s(ye);ma=i(Tn,"State"),Tn.forEach(t),ua=i(p," interface, but all the methods will be forwarded/delegated to the internal concrete state."),O=l(p,"UL",{});var $e=s(O);Se=l($e,"LI",{});var Ln=s(Se);pa=i(Ln,"This object is what users/clients will interact with."),Ln.forEach(t),ga=c($e),Te=l($e,"LI",{});var In=s(Te);va=i(In,"The state of this object changes by changing the internal concrete state field."),In.forEach(t),$e.forEach(t),p.forEach(t),Ea=c(E),b=l(E,"LI",{});var j=s(b);wa=i(j,"For each node in your state diagram, create a concrete class/type that implements the "),Le=l(j,"CODE",{});var Cn=s(Le);ba=i(Cn,"State"),Cn.forEach(t),_a=i(j," interface, and also has a field pointing to the "),Ie=l(j,"CODE",{});var kn=s(Ie);ya=i(kn,"Context"),kn.forEach(t),Sa=i(j," object."),_=l(j,"UL",{});var J=s(_);y=l(J,"LI",{});var K=s(y);Ta=i(K,"Each concrete state\u2019s implementation of the "),Ce=l(K,"CODE",{});var xn=s(Ce);La=i(xn,"State"),xn.forEach(t),Ia=i(K," interface can then have its own isolated business logic and behaviour and do "),ke=l(K,"CODE",{});var Mn=s(ke);Ca=i(Mn,"Context.changeState(newState)"),Mn.forEach(t),ka=i(K," when appropriate."),K.forEach(t),xa=c(J),xe=l(J,"LI",{});var Fn=s(xe);Ma=i(Fn,"This means concrete states are aware of each other."),Fn.forEach(t),Fa=c(J),Me=l(J,"LI",{});var Dn=s(Me);Da=i(Dn,"Not all methods in all states need to initiate state transition, or even do anything. For example, in vending machine no credit state, pressing the \u201Cdispense drink\u201D button should do nothing!"),Dn.forEach(t),J.forEach(t),j.forEach(t),Oa=c(E),S=l(E,"LI",{});var Q=s(S);ja=i(Q,"To use, create a "),Fe=l(Q,"CODE",{});var On=s(Fe);Pa=i(On,"Context"),On.forEach(t),qa=i(Q," object that initialises with an initial concrete state. Then call the "),De=l(Q,"CODE",{});var jn=s(De);Ua=i(jn,"State"),jn.forEach(t),Ha=i(Q," interface methods as needed."),Q.forEach(t),E.forEach(t)},m(a,r){d(a,T,r),e(T,et),d(a,Oe,r),d(a,P,r),e(P,tt),d(a,je,r),d(a,q,r),e(q,at),d(a,Pe,r),d(a,U,r),e(U,nt),d(a,qe,r),d(a,m,r),e(m,it),e(m,X),e(X,ot),e(m,lt),e(m,Y),e(Y,st),e(m,rt),e(m,Z),e(Z,ht),e(m,ct),e(m,$),e($,dt),e(m,ft),e(m,ee),e(ee,mt),e(m,ut),d(a,Ue,r),d(a,H,r),e(H,pt),d(a,He,r),d(a,w,r),e(w,C),e(C,gt),e(C,te),e(te,vt),e(C,Et),e(w,wt),e(w,ae),e(ae,bt),e(w,_t),e(w,ne),e(ne,yt),d(a,We,r),d(a,W,r),e(W,St),d(a,Ve,r),d(a,V,r),e(V,Tt),d(a,Ae,r),d(a,g,r),e(g,k),e(k,Lt),e(k,ie),e(ie,It),e(k,Ct),e(g,kt),e(g,x),e(x,xt),e(x,oe),e(oe,Mt),e(x,Ft),e(g,Dt),e(g,le),e(le,Ot),e(g,jt),e(g,A),e(A,Pt),e(A,se),e(se,re),e(re,qt),d(a,Be,r),d(a,B,r),e(B,Ut),d(a,Ne,r),d(a,L,r),e(L,he),e(he,Ht),e(L,Wt),e(L,ce),e(ce,Vt),d(a,Ge,r),d(a,N,r),e(N,At),d(a,Re,r),d(a,u,r),e(u,G),e(G,Bt),e(G,M),e(M,de),e(de,Nt),e(M,Gt),e(M,fe),e(fe,Rt),e(u,zt),e(u,R),e(R,Jt),e(R,F),e(F,me),e(me,Kt),e(F,Qt),e(F,ue),e(ue,pe),e(pe,Xt),e(u,Yt),e(u,D),e(D,Zt),e(D,ge),e(ge,$t),e(D,ea),e(u,ta),e(u,f),e(f,aa),e(f,ve),e(ve,na),e(f,ia),e(f,Ee),e(Ee,oa),e(f,la),e(f,we),e(we,sa),e(f,ra),e(f,be),e(be,ha),e(f,ca),e(f,_e),e(_e,da),e(f,fa),e(f,ye),e(ye,ma),e(f,ua),e(f,O),e(O,Se),e(Se,pa),e(O,ga),e(O,Te),e(Te,va),e(u,Ea),e(u,b),e(b,wa),e(b,Le),e(Le,ba),e(b,_a),e(b,Ie),e(Ie,ya),e(b,Sa),e(b,_),e(_,y),e(y,Ta),e(y,Ce),e(Ce,La),e(y,Ia),e(y,ke),e(ke,Ca),e(y,ka),e(_,xa),e(_,xe),e(xe,Ma),e(_,Fa),e(_,Me),e(Me,Da),e(u,Oa),e(u,S),e(S,ja),e(S,Fe),e(Fe,Pa),e(S,qa),e(S,De),e(De,Ua),e(S,Ha)},p:Ba,i:Ba,o:Ba,d(a){a&&t(T),a&&t(Oe),a&&t(P),a&&t(je),a&&t(q),a&&t(Pe),a&&t(U),a&&t(qe),a&&t(m),a&&t(Ue),a&&t(H),a&&t(He),a&&t(w),a&&t(We),a&&t(W),a&&t(Ve),a&&t(V),a&&t(Ae),a&&t(g),a&&t(Be),a&&t(B),a&&t(Ne),a&&t(L),a&&t(Ge),a&&t(N),a&&t(Re),a&&t(u)}}}const An={title:"Finite State Machine (State Design Pattern)",date:"2024-06-16"},{title:Pn,date:Nn}=An;class Gn extends Un{constructor(T){super(),Hn(this,T,null,Vn,Wn,{})}}export{Gn as default,An as metadata};
