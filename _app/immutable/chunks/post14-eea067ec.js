import{S as Wc,i as Bc,s as zc,k as i,q as a,a as h,l,m as n,r as s,h as o,c,n as ce,b as d,B as t,A as ld}from"./index-39c5cc75.js";function Fc(Lc){let z,Rs,Ko,F,Ss,oe,Ps,Cs,Xo,pe,qs,Zo,D,dt,As,Ls,ht,Ns,Hs,ct,Ws,$o,ue,Bs,ea,fe,pt,zs,ta,me,Fs,oa,Ee,ut,Ms,aa,M,Gs,ft,js,Us,sa,be,mt,Ys,ia,ye,Js,la,y,Qs,Et,Vs,Ks,bt,Xs,Zs,yt,$s,ei,vt,ti,oi,na,ve,wt,ai,ra,G,si,xt,ii,li,da,we,_t,ni,ha,xe,ri,ca,k,Tt,di,hi,gt,ci,pi,ae,ui,Dt,fi,mi,pa,_e,Ei,ua,se,kt,bi,yi,fa,j,vi,Ot,wi,xi,ma,p,It,_i,Ti,Rt,gi,Di,Te,ki,St,L,Oi,Pt,Ii,Ri,Ct,Si,Pi,Ci,qt,qi,Ai,N,Li,At,Ni,Hi,Lt,Wi,Bi,zi,H,Fi,Nt,Mi,Gi,Ht,ji,Ui,Yi,W,Ji,Wt,Qi,Vi,Bt,Ki,Xi,Zi,ge,$i,ie,zt,el,tl,le,ol,Ft,al,sl,il,Mt,ll,nl,Gt,rl,Ea,De,dl,ba,U,hl,jt,cl,pl,ya,Y,ul,Ut,fl,ml,va,ke,Yt,El,wa,Oe,bl,xa,Ie,Jt,yl,_a,O,vl,Qt,wl,xl,Vt,_l,Tl,Ta,Re,Kt,gl,ga,J,Dl,Xt,kl,Ol,Da,Se,Il,ka,Pe,Rl,Oa,Ce,Zt,Sl,Ia,qe,Pl,Ra,Ae,$t,Cl,Sa,Q,ql,eo,Al,Ll,Pa,V,Nl,to,Hl,Wl,Ca,Le,oo,Bl,qa,Ne,zl,Aa,He,Fl,La,I,Ml,ao,Gl,jl,so,Ul,Yl,Na,u,Jl,io,Ql,Vl,lo,Kl,Xl,B,Zl,no,$l,en,ro,tn,on,an,ho,sn,ln,co,nn,rn,po,dn,hn,uo,cn,pn,Ha,We,un,Wa,Be,fn,Ba,ne,fo,mn,En,za,ze,bn,Fa,K,yn,mo,vn,wn,Ma,Fe,xn,Ga,X,_n,Eo,Tn,gn,ja,v,Dn,bo,kn,On,yo,In,Rn,vo,Sn,Pn,wo,Cn,qn,Ua,m,An,xo,Ln,Nn,_o,Hn,Wn,To,Bn,zn,go,Fn,Mn,Do,Gn,jn,Ya,w,Un,ko,Yn,Jn,re,Qn,Vn,Oo,Kn,Xn,Io,Zn,$n,Ja,Z,er,de,tr,or,Qa,Me,ar,Va,_,sr,Ro,ir,lr,So,nr,rr,Po,dr,hr,Ka,R,cr,Co,pr,ur,qo,fr,mr,Xa,E,Er,Ao,br,yr,Lo,vr,wr,No,xr,_r,Ho,Tr,gr,Wo,Dr,kr,Za,x,Or,Bo,Ir,Rr,zo,Sr,Pr,Fo,Cr,qr,Mo,Ar,Lr,$a,Ge,Nr,es,je,Go,Hr,ts,$,Wr,jo,Br,zr,os,Ue,Fr,as,Ye,Mr,ss,Je,Uo,Gr,is,ee,jr,Yo,Ur,Yr,ls,Qe,Jo,Jr,ns,Ve,Qr,rs,Ke,Vr,ds,he,Nc=`<code class="language-sql"><span class="token keyword">SELECT</span> column1<span class="token punctuation">,</span> column2
<span class="token keyword">FROM</span> my_table
<span class="token keyword">WHERE</span> date_column <span class="token operator">></span> ? <span class="token operator">AND</span> id_column <span class="token operator">=</span><span class="token operator">=</span> ?</code>`,hs,S,Kr,Qo,Xr,Zr,Vo,$r,ed,cs,Xe,td;return{c(){z=i("h1"),Rs=a(Ac),Ko=h(),F=i("p"),Ss=a("Recently read an extremely informative e-book on database indexing over at "),oe=i("a"),Ps=a("use-the-index-luke"),Cs=a(`.
This post is to synthesise and summarise the main learnings that I took away from the ~200 page e-book.`),Xo=h(),pe=i("h1"),qs=a("The Three Powers of Indexing"),Zo=h(),D=i("ol"),dt=i("li"),As=a("B-Tree Traversal"),Ls=h(),ht=i("li"),Ns=a("Data Clustering"),Hs=h(),ct=i("li"),Ws=a("Pipelined Sorting"),$o=h(),ue=i("h2"),Bs=a("Data Structures Underlying the Index"),ea=h(),fe=i("p"),pt=i("strong"),zs=a("Redundant/Duplicated Data"),ta=h(),me=i("p"),Fs=a(`An index is (usually) a separate data structure maintained by the database.
In other words, it is redundant data that is stored/managed on top of the actual data that is stored/managed in your table.
An index is powered by two key data structures: Doubly Linked List and B-Tree.
One node corresponds to one database block.`),oa=h(),Ee=i("p"),ut=i("strong"),Ms=a("Database block / Database page"),aa=h(),M=i("p"),Gs=a(`A database block or page is the smallest (size) unit of operation, usually about 4 kilobytes in size.
The data in one block is physically arranged in a `),ft=i("em"),js=a("contiguous"),Us=a(` block of memory.
One block can usually store multiple rows of the table data, or multiple index entries.
This means that in order to read a single row within a block that contains multiple rows, the database will have to read the entire block.`),sa=h(),be=i("p"),mt=i("strong"),Ys=a("Doubly Linked List"),ia=h(),ye=i("p"),Js=a(`The doubly linked lists\u2019 nodes are actually the leaf nodes for the B-tree.
Each node has multiple index entries, sorted by the index key.
Each entry in the node will store the index key(s) and also a pointer (ROWID) to the corresponding (physical) location of the data row.
Each node is also connected to the next higher entry (leaf) node and next lower (leaf) entry node, giving it the ability to move up and down the index keys in all the leaf nodes (double linked list).
This effectively makes the index entries and the index nodes all sorted.`),la=h(),y=i("p"),Qs=a("The important thing to note here is that accessing all ROWID rows contained in one single index node is most likely a "),Et=i("strong"),Vs=a("random operation"),Ks=a(` because row data is stored in the heap and there are no guarantees that it is ordered.
This is further exacerbated by having to read the ROWIDs sequentially as they appear and also having to access row data `),bt=i("em"),Xs=a("in blocks"),Zs=a(`.
The implication is that scanning through the ROWIDs could mean `),yt=i("em"),$s=a("accessing the same blocks multiple times"),ei=a(" to read different rows in the same block, effectively making using the index "),vt=i("em"),ti=a("slower"),oi=a(` than a full etable scan!
Of course, the database optimizer will try avoid this using its cost metrics and estimation.`),na=h(),ve=i("p"),wt=i("strong"),ai=a("B-tree"),ra=h(),G=i("p"),si=a(`The B-tree forms the upper \u2018layers\u2019 of the index. Each leaf node\u2019s highest value will be connected to the node in the layer above.
The node in the layer above consists of the highest (index key) values of several child nodes; depending on the block size, it can store ~100 values.
This process is repeated for every branch layer until the tree like structure (root node) is formed.
The `),xt=i("code"),ii=a("B"),li=a(` stands for balanced, which means that the depth of the deepest node is at most 1 layer deeper than the rest.
The B-tree allows log(n) lookups, therefore traversing the tree is very fast.`),da=h(),we=i("p"),_t=i("strong"),ni=a("Types of Index Operations"),ha=h(),xe=i("p"),ri=a("There are three different ways that the DB optimizer can use index predicates, with drastically different performance characteristics."),ca=h(),k=i("ol"),Tt=i("li"),di=a("Index unique scan, where only tree traversal is necessary. This of course requires unique constraint to be in place. (Super fast)"),hi=h(),gt=i("li"),ci=a("Index range scan, where the DB will perform both tree traversal as well as follow leaf nodes to find all matching entires. Aka index access predicates (Good enough)"),pi=h(),ae=i("li"),ui=a("Table access by index ROWID, where the DB will follow the ROWID pointer to read the row, then perform the filter based on what is found in the row. Aka index filter predicates. (Can be dangerous as it depends on table size "),Dt=i("em"),fi=a("not"),mi=a(" query size)"),pa=h(),_e=i("h2"),Ei=a("WHERE clause"),ua=h(),se=i("p"),kt=i("code"),bi=a("WHERE"),yi=a(` clauses are the main utiliser of indexes.
The overarching theme and guideline here is to keep indexed columns as they are, and do functions/operations on the other side of the predicates.`),fa=h(),j=i("p"),vi=a("Some key points to effectively write "),Ot=i("code"),wi=a("WHERE"),xi=a(" clause:"),ma=h(),p=i("ul"),It=i("li"),_i=a("As much as possible, do not wrap indexed columns within functions, because optimiser treats these as black boxes."),Ti=h(),Rt=i("li"),gi=a("If functions are unavoidable, create a function based index."),Di=h(),Te=i("li"),ki=a("The order of columns in the index definition is very important. Choose an order that can be used as often as possible."),St=i("ul"),L=i("li"),Oi=a("Queries can only use index when the "),Pt=i("code"),Ii=a("WHERE"),Ri=a(" clause contains \u201Ccumulation\u201D of the index columns starting from the left. E.g. For index with (col1, col2, col3), "),Ct=i("code"),Si=a("WHERE"),Pi=a(" clause with either col1, col1 + col2, or col1 + col2 + col3 can use the index, whereas all other predicates are unable to use the index due to how the underlying index keys are sorted."),Ci=h(),qt=i("li"),qi=a("When creating index, prioritise equality first then for range predicates."),Ai=h(),N=i("li"),Li=a("For "),At=i("code"),Ni=a("LIKE 'abc%xyz'"),Hi=a(" predicates, only the part infront of the "),Lt=i("code"),Wi=a("%"),Bi=a(" is used for access predicates."),zi=h(),H=i("li"),Fi=a("Avoid "),Nt=i("code"),Mi=a("LIKE"),Gi=a(" on date types as it internally applies "),Ht=i("code"),ji=a("TO_STRING()"),Ui=a(" which obfuscates the index."),Yi=h(),W=i("li"),Ji=a("When working with numeric strings, make sure to supply a string as predicate to avoid type conversion which obfuscates index ("),Wt=i("code"),Qi=a("WHERE string_col = 42"),Vi=a(" vs "),Bt=i("code"),Ki=a('WHERE string_col = "42"'),Xi=a(")."),Zi=h(),ge=i("li"),$i=a("Combining columns also obfuscates index (e.g. filtering on date_column + time_column)."),ie=i("ul"),zt=i("li"),el=a("If possible, add combined column into table and index"),tl=h(),le=i("li"),ol=a("If not possible, use \u201Credundant\u201D predicate on a single column so that predicate can take advantage of the index (e.g. "),Ft=i("code"),al=a("WHERE ADDTIME(date_col, time_col) > DATEADD(now(), INTERVAL '1 day') AND date_col >= DATE(DATE_ADD(now(), INTERVAL '1 day'))"),sl=a(", the second predicate is redundant but able to use index on date_col)."),il=h(),Mt=i("li"),ll=a("Partial indexing (indexing only certain rows) may be useful on certain workloads to reduce index size and improve update performance on non-indexed rows."),nl=h(),Gt=i("li"),rl=a("When index causes problems for a particular query,"),Ea=h(),De=i("h2"),dl=a("JOIN operations"),ba=h(),U=i("p"),hl=a(`JOINs in databases are done 2 tables at a time. If multiple JOINs are needed then DB will do it recursively 2 tables at a time.
This means the optimiser has to evaluate the `),jt=i("code"),cl=a("n!"),pl=a(` join order permutations to come up with the best execution plan.
Therefore, the more complex the query, the more important using prepared statements become.`),ya=h(),Y=i("p"),ul=a("There are 3 types of "),Ut=i("code"),fl=a("JOIN"),ml=a(" algorithms:"),va=h(),ke=i("p"),Yt=i("strong"),El=a("Nested Loop Join"),wa=h(),Oe=i("p"),bl=a(`Nested loop join operates like a nested for loop: for each join key in table 1, find the corresponding key in table 2.
To improve performance, index the join key columns.
This algorithm is performant when rows returned by the \u2018outer loop\u2019 is low.`),xa=h(),Ie=i("p"),Jt=i("strong"),yl=a("Hash Join"),_a=h(),O=i("p"),vl=a(`Hash join operates by loading all the keys (and rows) of one table in-memory, so that the other table can keep looking up the corresponding join key.
Indexing join key columns for this algorithm is useless as the keys are already in-memory!
Hence, it is better to index the independent `),Qt=i("code"),wl=a("WHERE"),xl=a(` clause to improve performance.
Another way to improve hash join performance is to reduce the memory footprint of the hash table, this implies both selecting less rows `),Vt=i("em"),_l=a("as well as less columns"),Tl=a("."),Ta=h(),Re=i("p"),Kt=i("strong"),gl=a("Sort Merge Join"),ga=h(),J=i("p"),Dl=a("Sort merge join operates by combining 2 "),Xt=i("em"),kl=a("sorted"),Ol=a(` tables (like a zipper). It iteratively loads the smallest keys from the two tables and do a cartesian product on them.
Sort merge join can be sped up if the keys are presorted (from an index or from another sort operation in the query).`),Da=h(),Se=i("h2"),Il=a("Data Clustering"),ka=h(),Pe=i("p"),Rl=a(`Besides enabling fast lookups, indexes provide data clustering.
Data clustering in this case means to store consecutively accessed data close to each other (physically) so that accessing them requires fewer IO operations.
Values that the query plan is interested in can be found on the index itself.
This is especially useful for two things: optimizing index filter predicates and enabling index only scans.`),Oa=h(),Ce=i("p"),Zt=i("strong"),Sl=a("Optimizing Index Filter Predicates"),Ia=h(),qe=i("p"),Pl=a(`If query is bottlenecked by table access by index ROWID => filter predicate, then adding those columns that appear in these filter predicate into the index will speed up the query, since the values can now be found in the index instead of having to access the table rows.
When doing this, remember to always prioritise optimising for index access predicates first (i.e. Btree traversal) before optimizing for index filter predicates!
Also, do extend the current index instead of creating a new index to minimise index maintenance effort.`),Ra=h(),Ae=i("p"),$t=i("strong"),Cl=a("Enabling Index Only Scans"),Sa=h(),Q=i("p"),ql=a("This takes the above concept to the extreme, where all "),eo=i("code"),Al=a("SELECT"),Ll=a(`ed columns are added into the index so the query skips accessing the heap table entirely.
Note that performance improvement depends on number of accessed rows (more improvement when nrows is high) and the index clustering factor of the query without the index (more improvement when clustering factor was high).`),Pa=h(),V=i("p"),Nl=a("An index that covers the entire query is called a "),to=i("em"),Hl=a("covering index"),Wl=a("."),Ca=h(),Le=i("p"),oo=i("strong"),Bl=a("Index-Organized Tables aka Clustered Index"),qa=h(),Ne=i("p"),zl=a(`Another way to achieve data clustering is to order the table physically by the index keys, called \u201CClustered Index\u201D in MS SQL Server.
This have the benefit of enabling index only scans on all queries, but the drawback is that row access through secondary indexes require traversing the table tree (instead of just following the ROWID pointer).
A general guideline is that tables with one index benefit from being Index-Organized table, while tables with many indexes usually benefit from heap table.`),Aa=h(),He=i("h2"),Fl=a("ORDER BY"),La=h(),I=i("p"),Ml=a(`As mentioned, indexes have pre-sorted data based on the index keys.
Hence, to optimize `),ao=i("code"),Gl=a("ORDER BY"),jl=a(" queries, add all sorting columns into index that is used by the "),so=i("code"),Ul=a("WHERE"),Yl=a(" clause."),Na=h(),u=i("p"),Jl=a("Although adding "),io=i("code"),Ql=a("ASC"),Vl=a("/"),lo=i("code"),Kl=a("DESC"),Xl=a(` homogeneously to all sorting columns can take advantage of the same index (due to double linked list being able to traverse both directions),
`),B=i("em"),Zl=a("mixing "),no=i("code"),$l=a("ASC"),en=a(" and "),ro=i("code"),tn=a("DESC"),on=a(" will prevent the use of the original index as it will result in a different in ordering between the query and index"),an=a(`.
For example, `),ho=i("code"),sn=a("ORDER BY date_col ASC, product_id ASC"),ln=a(" and "),co=i("code"),nn=a("ORDER BY date_col DESC, product_id DESC"),rn=a(" can use the same index, but "),po=i("code"),dn=a("ORDER BY date_col ASC, product_id DESC"),hn=a(" will "),uo=i("em"),cn=a("not"),pn=a(" be able to use the same index!"),Ha=h(),We=i("p"),un=a("It is also important to note that, for large queries, full table scan + sorting may actually be faster than accesing table rows through index due to the \u201Crandom IO\u201D nature of accessing table rows."),Wa=h(),Be=i("h2"),fn=a("GROUP BY"),Ba=h(),ne=i("p"),fo=i("code"),mn=a("GROUP BY"),En=a(` has 2 main algorithms: Hash Table algorithm and Sort/Group algorithm.
Hash Table algorithm stores a (temporary) hash table with grouping column as keys, then aggregates that inputs into this hash table.
Sort/Group algorithm sorts the inputs by grouping column, then aggregates the sorted input.`),za=h(),ze=i("p"),bn=a("Notice that although both needs to materialise an intermediate state, but Hash Table\u2019s memory footprint is way smaller than Sort/Group\u2019s sorted input, therefore usually optimizer prefers Hash Table algo."),Fa=h(),K=i("p"),yn=a("Only the Sort/Group algorithm can make use of index to optmize its performance, and the advantage it has over Hash Table algo is that it enables "),mo=i("em"),vn=a("pipelined execution"),wn=a(" of the query."),Ma=h(),Fe=i("h2"),xn=a("Partial Results"),Ga=h(),X=i("p"),_n=a("Indexes enables pipelined "),Eo=i("code"),Tn=a("ORDER BY"),gn=a(" execution, which optimizes pagination queries by returning results without needing to read the entire table."),ja=h(),v=i("p"),Dn=a("Therefore, for queries that require partial results (e.g. fetch first 10 IDs), indexing all "),bo=i("code"),kn=a("ORDER BY"),On=a(` columns enables pipelining and therefore greatly reduces latency of the query.
The database will stop execution and return as soon as it has found the required number of rows.
For \u201CTop N\u201D queries, this means that response time of pipelined \u201CTop N\u201D queries grows with number of rows `),yo=i("strong"),In=a("selected"),Rn=a(` instead of table size!
\u201CTop N\u201D queries can be done using `),vo=i("code"),Sn=a("LIMIT"),Pn=a(" or "),wo=i("code"),Cn=a("FETCH FIRST N ROWS"),qn=a(" clause."),Ua=h(),m=i("p"),An=a(`For paging through the next N results, there are actually two ways to do this.
The normal way is to add the `),xo=i("code"),Ln=a("OFFSET"),Nn=a(" extension clause into the "),_o=i("code"),Hn=a("LIMIT"),Wn=a("/"),To=i("code"),Bn=a("FETCH FIRST"),zn=a(` clauses.
However there are 2 disadvantages to this:
the query results will \u201Cdrift\u201D if there were inserts;
and the query actually `),go=i("em"),Fn=a("slows"),Mn=a(" down the further "),Do=i("code"),Gn=a("OFFSET"),jn=a(" you put, since the database has to scan and count the index before returning the desired rows."),Ya=h(),w=i("p"),Un=a("The other method is to use "),ko=i("code"),Yn=a("WHERE"),Jn=a(` clause on the last fetched row of the previous page. This will have big performance benefit since it uses tree traversal to find the relevant rows to skip.
To implement this, it is possible to use `),re=i("a"),Qn=a("row value comparison"),Vn=a(" if supported by your database, "),Oo=i("code"),Kn=a("WHERE (sale_date, sale_id) < (?, ?)"),Xn=a(`, as the logic matches the sorting logic.
If not, it is possible, but less efficient, to do normal comparisons, `),Io=i("code"),Zn=a("WHERE sale_date <= ? AND NOT (sale_date = ? AND sale_id >= ?)"),$n=a(`.
This method\u2019s disadvantage is that you are not able to \u201Cjump\u201D straight to page N, since you require the previous page\u2019s last value. But it is still good for \u2018infinite scrolling\u2019 pages.`),Ja=h(),Z=i("p"),er=a("For more detailed explanation, do read through the original article at "),de=i("a"),tr=a("use the index luke"),or=a("."),Qa=h(),Me=i("h2"),ar=a("INSERT, DELETE, UPDATE"),Va=h(),_=i("p"),sr=a(`Since indexes are purely redundant/duplicate data that exists on top of the actual table\u2019s data, this requires compute time to keep both indexes and table in sync, as well as maintain the underlying index data structure.
Therefore, the performance of `),Ro=i("code"),ir=a("INSERT"),lr=a(", "),So=i("code"),nr=a("DELETE"),rr=a(" and "),Po=i("code"),dr=a("UPDATE"),hr=a(" all degrade proportionally to the number of indexes the table has."),Ka=h(),R=i("p"),cr=a("For "),Co=i("code"),pr=a("INSERT"),ur=a("s, it is important to note that the "),qo=i("em"),fr=a("first index, i.e. going from 0 to 1 index, makes the greatest difference in performance"),mr=a(` (several orders of magnitude more degradation, compared to adding more indexes when you already have one).
This property can be useful when you are bulk loading large amounts of data, which you can temporarily drop the index to load much faster.`),Xa=h(),E=i("p"),Er=a("For "),Ao=i("code"),br=a("DELETE"),yr=a("s, the execution acts like "),Lo=i("code"),vr=a("SELECT"),wr=a(` with extra delete step at the end.
Hence `),No=i("code"),xr=a("DELETE"),_r=a("ing a single row with no index does not gain the same speed up as "),Ho=i("code"),Tr=a("INSERT"),gr=a(" (as it requires full table scan), but it may still make sense when "),Wo=i("code"),Dr=a("DELETE"),kr=a("ing many rows."),Za=h(),x=i("p"),Or=a("For "),Bo=i("code"),Ir=a("UPDATE"),Rr=a("s, the execution acts like a "),zo=i("code"),Sr=a("DELETE"),Pr=a(" + "),Fo=i("code"),Cr=a("INSERT"),qr=a(" operation. The important thing about "),Mo=i("code"),Ar=a("UPDATE"),Lr=a(`s is that changed values/columns may not be present in all indexes, therefore it is important to only update the columns that needs updating.
This might not apply when writing the SQL manually, but when using ORM tools this could be a hidden performance trap if not careful.`),$a=h(),Ge=i("h2"),Nr=a("Glossary"),es=h(),je=i("p"),Go=i("strong"),Hr=a("Pipelining"),ts=h(),$=i("p"),Wr=a(`Pipelining / Pipelined Execution is a way in which database executes the operations from the query plan.
Pipelined Execution works \u201Crow-by-row\u201D and passes the row/tuple to the next operation immediately after the current operation is done.
Pipelined execution is advantageous because it reduces response time of your query, especially for `),jo=i("code"),Br=a("LIMIT"),zr=a(" type queries."),os=h(),Ue=i("p"),Fr=a(`This is in contrast to another way of execution (Materlisation Execution Model), which is to wait for the entire intermediate output to materialise, then pass on to the next operation.
A similar analogy is the difference between stream processing vs batch processing.`),as=h(),Ye=i("p"),Mr=a(`OLAP databases also take pipelining one step further and implements Vectorized Execution. In Vectorized Execution, instead of returning \u201Crow-by-row\u201D, the operator returns \u201Cbatch-by-batch\u201D, i.e. small batches of rows instead of a single row.
This greatly reduces number of CPU cycles needed per operator, and also allows operators to take advantage of CPU\u2019s SIMD instructions (Single Instruction Multiple Data) to speed up the query.`),ss=h(),Je=i("p"),Uo=i("strong"),Gr=a("Clustering Factor"),is=h(),ee=i("p"),jr=a(`Clustering factor is how correlated the sequence of the column\u2019s data values are to the sequence of their physical order.
In Oracle, the clustering factor value is `),Yo=i("em"),Ur=a("low"),Yr=a(` when the sequences are correlated.
While in Postgres, they use actual Pearson correlation, so when value is 0 is totally uncorrelated and when value is 1 (or -1) they are totally correlated.`),ls=h(),Qe=i("p"),Jo=i("strong"),Jr=a("Prepared Statements/Bind Parameters"),ns=h(),Ve=i("p"),Qr=a("Prepared statements are SQL template statements which have placeholders in certain clauses that can be filled on the next run."),rs=h(),Ke=i("p"),Vr=a("For example:"),ds=h(),he=i("pre"),hs=h(),S=i("p"),Kr=a("The above statement is a prepared statement as there are "),Qo=i("code"),Xr=a("?"),Zr=a(" in the "),Vo=i("code"),$r=a("WHERE"),ed=a(" clause. Actual values will be sent by the application to the database on the subsequent calls to this prepared statement."),cs=h(),Xe=i("p"),td=a("Prepared statements are highly recommended because it prevents SQL injection attacks. It also prevents re-run of query optimizer everytime the query is sent to the database, this reduces latency since the database can re-use the same query plan for this prepared statement, which is especially important for complex queries!"),this.h()},l(e){z=l(e,"H1",{});var r=n(z);Rs=s(r,Ac),r.forEach(o),Ko=c(e),F=l(e,"P",{});var ps=n(F);Ss=s(ps,"Recently read an extremely informative e-book on database indexing over at "),oe=l(ps,"A",{href:!0,rel:!0});var nd=n(oe);Ps=s(nd,"use-the-index-luke"),nd.forEach(o),Cs=s(ps,`.
This post is to synthesise and summarise the main learnings that I took away from the ~200 page e-book.`),ps.forEach(o),Xo=c(e),pe=l(e,"H1",{});var rd=n(pe);qs=s(rd,"The Three Powers of Indexing"),rd.forEach(o),Zo=c(e),D=l(e,"OL",{});var Ze=n(D);dt=l(Ze,"LI",{});var dd=n(dt);As=s(dd,"B-Tree Traversal"),dd.forEach(o),Ls=c(Ze),ht=l(Ze,"LI",{});var hd=n(ht);Ns=s(hd,"Data Clustering"),hd.forEach(o),Hs=c(Ze),ct=l(Ze,"LI",{});var cd=n(ct);Ws=s(cd,"Pipelined Sorting"),cd.forEach(o),Ze.forEach(o),$o=c(e),ue=l(e,"H2",{});var pd=n(ue);Bs=s(pd,"Data Structures Underlying the Index"),pd.forEach(o),ea=c(e),fe=l(e,"P",{});var ud=n(fe);pt=l(ud,"STRONG",{});var fd=n(pt);zs=s(fd,"Redundant/Duplicated Data"),fd.forEach(o),ud.forEach(o),ta=c(e),me=l(e,"P",{});var md=n(me);Fs=s(md,`An index is (usually) a separate data structure maintained by the database.
In other words, it is redundant data that is stored/managed on top of the actual data that is stored/managed in your table.
An index is powered by two key data structures: Doubly Linked List and B-Tree.
One node corresponds to one database block.`),md.forEach(o),oa=c(e),Ee=l(e,"P",{});var Ed=n(Ee);ut=l(Ed,"STRONG",{});var bd=n(ut);Ms=s(bd,"Database block / Database page"),bd.forEach(o),Ed.forEach(o),aa=c(e),M=l(e,"P",{});var us=n(M);Gs=s(us,`A database block or page is the smallest (size) unit of operation, usually about 4 kilobytes in size.
The data in one block is physically arranged in a `),ft=l(us,"EM",{});var yd=n(ft);js=s(yd,"contiguous"),yd.forEach(o),Us=s(us,` block of memory.
One block can usually store multiple rows of the table data, or multiple index entries.
This means that in order to read a single row within a block that contains multiple rows, the database will have to read the entire block.`),us.forEach(o),sa=c(e),be=l(e,"P",{});var vd=n(be);mt=l(vd,"STRONG",{});var wd=n(mt);Ys=s(wd,"Doubly Linked List"),wd.forEach(o),vd.forEach(o),ia=c(e),ye=l(e,"P",{});var xd=n(ye);Js=s(xd,`The doubly linked lists\u2019 nodes are actually the leaf nodes for the B-tree.
Each node has multiple index entries, sorted by the index key.
Each entry in the node will store the index key(s) and also a pointer (ROWID) to the corresponding (physical) location of the data row.
Each node is also connected to the next higher entry (leaf) node and next lower (leaf) entry node, giving it the ability to move up and down the index keys in all the leaf nodes (double linked list).
This effectively makes the index entries and the index nodes all sorted.`),xd.forEach(o),la=c(e),y=l(e,"P",{});var P=n(y);Qs=s(P,"The important thing to note here is that accessing all ROWID rows contained in one single index node is most likely a "),Et=l(P,"STRONG",{});var _d=n(Et);Vs=s(_d,"random operation"),_d.forEach(o),Ks=s(P,` because row data is stored in the heap and there are no guarantees that it is ordered.
This is further exacerbated by having to read the ROWIDs sequentially as they appear and also having to access row data `),bt=l(P,"EM",{});var Td=n(bt);Xs=s(Td,"in blocks"),Td.forEach(o),Zs=s(P,`.
The implication is that scanning through the ROWIDs could mean `),yt=l(P,"EM",{});var gd=n(yt);$s=s(gd,"accessing the same blocks multiple times"),gd.forEach(o),ei=s(P," to read different rows in the same block, effectively making using the index "),vt=l(P,"EM",{});var Dd=n(vt);ti=s(Dd,"slower"),Dd.forEach(o),oi=s(P,` than a full etable scan!
Of course, the database optimizer will try avoid this using its cost metrics and estimation.`),P.forEach(o),na=c(e),ve=l(e,"P",{});var kd=n(ve);wt=l(kd,"STRONG",{});var Od=n(wt);ai=s(Od,"B-tree"),Od.forEach(o),kd.forEach(o),ra=c(e),G=l(e,"P",{});var fs=n(G);si=s(fs,`The B-tree forms the upper \u2018layers\u2019 of the index. Each leaf node\u2019s highest value will be connected to the node in the layer above.
The node in the layer above consists of the highest (index key) values of several child nodes; depending on the block size, it can store ~100 values.
This process is repeated for every branch layer until the tree like structure (root node) is formed.
The `),xt=l(fs,"CODE",{});var Id=n(xt);ii=s(Id,"B"),Id.forEach(o),li=s(fs,` stands for balanced, which means that the depth of the deepest node is at most 1 layer deeper than the rest.
The B-tree allows log(n) lookups, therefore traversing the tree is very fast.`),fs.forEach(o),da=c(e),we=l(e,"P",{});var Rd=n(we);_t=l(Rd,"STRONG",{});var Sd=n(_t);ni=s(Sd,"Types of Index Operations"),Sd.forEach(o),Rd.forEach(o),ha=c(e),xe=l(e,"P",{});var Pd=n(xe);ri=s(Pd,"There are three different ways that the DB optimizer can use index predicates, with drastically different performance characteristics."),Pd.forEach(o),ca=c(e),k=l(e,"OL",{});var $e=n(k);Tt=l($e,"LI",{});var Cd=n(Tt);di=s(Cd,"Index unique scan, where only tree traversal is necessary. This of course requires unique constraint to be in place. (Super fast)"),Cd.forEach(o),hi=c($e),gt=l($e,"LI",{});var qd=n(gt);ci=s(qd,"Index range scan, where the DB will perform both tree traversal as well as follow leaf nodes to find all matching entires. Aka index access predicates (Good enough)"),qd.forEach(o),pi=c($e),ae=l($e,"LI",{});var ms=n(ae);ui=s(ms,"Table access by index ROWID, where the DB will follow the ROWID pointer to read the row, then perform the filter based on what is found in the row. Aka index filter predicates. (Can be dangerous as it depends on table size "),Dt=l(ms,"EM",{});var Ad=n(Dt);fi=s(Ad,"not"),Ad.forEach(o),mi=s(ms," query size)"),ms.forEach(o),$e.forEach(o),pa=c(e),_e=l(e,"H2",{});var Ld=n(_e);Ei=s(Ld,"WHERE clause"),Ld.forEach(o),ua=c(e),se=l(e,"P",{});var od=n(se);kt=l(od,"CODE",{});var Nd=n(kt);bi=s(Nd,"WHERE"),Nd.forEach(o),yi=s(od,` clauses are the main utiliser of indexes.
The overarching theme and guideline here is to keep indexed columns as they are, and do functions/operations on the other side of the predicates.`),od.forEach(o),fa=c(e),j=l(e,"P",{});var Es=n(j);vi=s(Es,"Some key points to effectively write "),Ot=l(Es,"CODE",{});var Hd=n(Ot);wi=s(Hd,"WHERE"),Hd.forEach(o),xi=s(Es," clause:"),Es.forEach(o),ma=c(e),p=l(e,"UL",{});var f=n(p);It=l(f,"LI",{});var Wd=n(It);_i=s(Wd,"As much as possible, do not wrap indexed columns within functions, because optimiser treats these as black boxes."),Wd.forEach(o),Ti=c(f),Rt=l(f,"LI",{});var Bd=n(Rt);gi=s(Bd,"If functions are unavoidable, create a function based index."),Bd.forEach(o),Di=c(f),Te=l(f,"LI",{});var ad=n(Te);ki=s(ad,"The order of columns in the index definition is very important. Choose an order that can be used as often as possible."),St=l(ad,"UL",{});var zd=n(St);L=l(zd,"LI",{});var et=n(L);Oi=s(et,"Queries can only use index when the "),Pt=l(et,"CODE",{});var Fd=n(Pt);Ii=s(Fd,"WHERE"),Fd.forEach(o),Ri=s(et," clause contains \u201Ccumulation\u201D of the index columns starting from the left. E.g. For index with (col1, col2, col3), "),Ct=l(et,"CODE",{});var Md=n(Ct);Si=s(Md,"WHERE"),Md.forEach(o),Pi=s(et," clause with either col1, col1 + col2, or col1 + col2 + col3 can use the index, whereas all other predicates are unable to use the index due to how the underlying index keys are sorted."),et.forEach(o),zd.forEach(o),ad.forEach(o),Ci=c(f),qt=l(f,"LI",{});var Gd=n(qt);qi=s(Gd,"When creating index, prioritise equality first then for range predicates."),Gd.forEach(o),Ai=c(f),N=l(f,"LI",{});var tt=n(N);Li=s(tt,"For "),At=l(tt,"CODE",{});var jd=n(At);Ni=s(jd,"LIKE 'abc%xyz'"),jd.forEach(o),Hi=s(tt," predicates, only the part infront of the "),Lt=l(tt,"CODE",{});var Ud=n(Lt);Wi=s(Ud,"%"),Ud.forEach(o),Bi=s(tt," is used for access predicates."),tt.forEach(o),zi=c(f),H=l(f,"LI",{});var ot=n(H);Fi=s(ot,"Avoid "),Nt=l(ot,"CODE",{});var Yd=n(Nt);Mi=s(Yd,"LIKE"),Yd.forEach(o),Gi=s(ot," on date types as it internally applies "),Ht=l(ot,"CODE",{});var Jd=n(Ht);ji=s(Jd,"TO_STRING()"),Jd.forEach(o),Ui=s(ot," which obfuscates the index."),ot.forEach(o),Yi=c(f),W=l(f,"LI",{});var at=n(W);Ji=s(at,"When working with numeric strings, make sure to supply a string as predicate to avoid type conversion which obfuscates index ("),Wt=l(at,"CODE",{});var Qd=n(Wt);Qi=s(Qd,"WHERE string_col = 42"),Qd.forEach(o),Vi=s(at," vs "),Bt=l(at,"CODE",{});var Vd=n(Bt);Ki=s(Vd,'WHERE string_col = "42"'),Vd.forEach(o),Xi=s(at,")."),at.forEach(o),Zi=c(f),ge=l(f,"LI",{});var sd=n(ge);$i=s(sd,"Combining columns also obfuscates index (e.g. filtering on date_column + time_column)."),ie=l(sd,"UL",{});var bs=n(ie);zt=l(bs,"LI",{});var Kd=n(zt);el=s(Kd,"If possible, add combined column into table and index"),Kd.forEach(o),tl=c(bs),le=l(bs,"LI",{});var ys=n(le);ol=s(ys,"If not possible, use \u201Credundant\u201D predicate on a single column so that predicate can take advantage of the index (e.g. "),Ft=l(ys,"CODE",{});var Xd=n(Ft);al=s(Xd,"WHERE ADDTIME(date_col, time_col) > DATEADD(now(), INTERVAL '1 day') AND date_col >= DATE(DATE_ADD(now(), INTERVAL '1 day'))"),Xd.forEach(o),sl=s(ys,", the second predicate is redundant but able to use index on date_col)."),ys.forEach(o),bs.forEach(o),sd.forEach(o),il=c(f),Mt=l(f,"LI",{});var Zd=n(Mt);ll=s(Zd,"Partial indexing (indexing only certain rows) may be useful on certain workloads to reduce index size and improve update performance on non-indexed rows."),Zd.forEach(o),nl=c(f),Gt=l(f,"LI",{});var $d=n(Gt);rl=s($d,"When index causes problems for a particular query,"),$d.forEach(o),f.forEach(o),Ea=c(e),De=l(e,"H2",{});var eh=n(De);dl=s(eh,"JOIN operations"),eh.forEach(o),ba=c(e),U=l(e,"P",{});var vs=n(U);hl=s(vs,`JOINs in databases are done 2 tables at a time. If multiple JOINs are needed then DB will do it recursively 2 tables at a time.
This means the optimiser has to evaluate the `),jt=l(vs,"CODE",{});var th=n(jt);cl=s(th,"n!"),th.forEach(o),pl=s(vs,` join order permutations to come up with the best execution plan.
Therefore, the more complex the query, the more important using prepared statements become.`),vs.forEach(o),ya=c(e),Y=l(e,"P",{});var ws=n(Y);ul=s(ws,"There are 3 types of "),Ut=l(ws,"CODE",{});var oh=n(Ut);fl=s(oh,"JOIN"),oh.forEach(o),ml=s(ws," algorithms:"),ws.forEach(o),va=c(e),ke=l(e,"P",{});var ah=n(ke);Yt=l(ah,"STRONG",{});var sh=n(Yt);El=s(sh,"Nested Loop Join"),sh.forEach(o),ah.forEach(o),wa=c(e),Oe=l(e,"P",{});var ih=n(Oe);bl=s(ih,`Nested loop join operates like a nested for loop: for each join key in table 1, find the corresponding key in table 2.
To improve performance, index the join key columns.
This algorithm is performant when rows returned by the \u2018outer loop\u2019 is low.`),ih.forEach(o),xa=c(e),Ie=l(e,"P",{});var lh=n(Ie);Jt=l(lh,"STRONG",{});var nh=n(Jt);yl=s(nh,"Hash Join"),nh.forEach(o),lh.forEach(o),_a=c(e),O=l(e,"P",{});var st=n(O);vl=s(st,`Hash join operates by loading all the keys (and rows) of one table in-memory, so that the other table can keep looking up the corresponding join key.
Indexing join key columns for this algorithm is useless as the keys are already in-memory!
Hence, it is better to index the independent `),Qt=l(st,"CODE",{});var rh=n(Qt);wl=s(rh,"WHERE"),rh.forEach(o),xl=s(st,` clause to improve performance.
Another way to improve hash join performance is to reduce the memory footprint of the hash table, this implies both selecting less rows `),Vt=l(st,"EM",{});var dh=n(Vt);_l=s(dh,"as well as less columns"),dh.forEach(o),Tl=s(st,"."),st.forEach(o),Ta=c(e),Re=l(e,"P",{});var hh=n(Re);Kt=l(hh,"STRONG",{});var ch=n(Kt);gl=s(ch,"Sort Merge Join"),ch.forEach(o),hh.forEach(o),ga=c(e),J=l(e,"P",{});var xs=n(J);Dl=s(xs,"Sort merge join operates by combining 2 "),Xt=l(xs,"EM",{});var ph=n(Xt);kl=s(ph,"sorted"),ph.forEach(o),Ol=s(xs,` tables (like a zipper). It iteratively loads the smallest keys from the two tables and do a cartesian product on them.
Sort merge join can be sped up if the keys are presorted (from an index or from another sort operation in the query).`),xs.forEach(o),Da=c(e),Se=l(e,"H2",{});var uh=n(Se);Il=s(uh,"Data Clustering"),uh.forEach(o),ka=c(e),Pe=l(e,"P",{});var fh=n(Pe);Rl=s(fh,`Besides enabling fast lookups, indexes provide data clustering.
Data clustering in this case means to store consecutively accessed data close to each other (physically) so that accessing them requires fewer IO operations.
Values that the query plan is interested in can be found on the index itself.
This is especially useful for two things: optimizing index filter predicates and enabling index only scans.`),fh.forEach(o),Oa=c(e),Ce=l(e,"P",{});var mh=n(Ce);Zt=l(mh,"STRONG",{});var Eh=n(Zt);Sl=s(Eh,"Optimizing Index Filter Predicates"),Eh.forEach(o),mh.forEach(o),Ia=c(e),qe=l(e,"P",{});var bh=n(qe);Pl=s(bh,`If query is bottlenecked by table access by index ROWID => filter predicate, then adding those columns that appear in these filter predicate into the index will speed up the query, since the values can now be found in the index instead of having to access the table rows.
When doing this, remember to always prioritise optimising for index access predicates first (i.e. Btree traversal) before optimizing for index filter predicates!
Also, do extend the current index instead of creating a new index to minimise index maintenance effort.`),bh.forEach(o),Ra=c(e),Ae=l(e,"P",{});var yh=n(Ae);$t=l(yh,"STRONG",{});var vh=n($t);Cl=s(vh,"Enabling Index Only Scans"),vh.forEach(o),yh.forEach(o),Sa=c(e),Q=l(e,"P",{});var _s=n(Q);ql=s(_s,"This takes the above concept to the extreme, where all "),eo=l(_s,"CODE",{});var wh=n(eo);Al=s(wh,"SELECT"),wh.forEach(o),Ll=s(_s,`ed columns are added into the index so the query skips accessing the heap table entirely.
Note that performance improvement depends on number of accessed rows (more improvement when nrows is high) and the index clustering factor of the query without the index (more improvement when clustering factor was high).`),_s.forEach(o),Pa=c(e),V=l(e,"P",{});var Ts=n(V);Nl=s(Ts,"An index that covers the entire query is called a "),to=l(Ts,"EM",{});var xh=n(to);Hl=s(xh,"covering index"),xh.forEach(o),Wl=s(Ts,"."),Ts.forEach(o),Ca=c(e),Le=l(e,"P",{});var _h=n(Le);oo=l(_h,"STRONG",{});var Th=n(oo);Bl=s(Th,"Index-Organized Tables aka Clustered Index"),Th.forEach(o),_h.forEach(o),qa=c(e),Ne=l(e,"P",{});var gh=n(Ne);zl=s(gh,`Another way to achieve data clustering is to order the table physically by the index keys, called \u201CClustered Index\u201D in MS SQL Server.
This have the benefit of enabling index only scans on all queries, but the drawback is that row access through secondary indexes require traversing the table tree (instead of just following the ROWID pointer).
A general guideline is that tables with one index benefit from being Index-Organized table, while tables with many indexes usually benefit from heap table.`),gh.forEach(o),Aa=c(e),He=l(e,"H2",{});var Dh=n(He);Fl=s(Dh,"ORDER BY"),Dh.forEach(o),La=c(e),I=l(e,"P",{});var it=n(I);Ml=s(it,`As mentioned, indexes have pre-sorted data based on the index keys.
Hence, to optimize `),ao=l(it,"CODE",{});var kh=n(ao);Gl=s(kh,"ORDER BY"),kh.forEach(o),jl=s(it," queries, add all sorting columns into index that is used by the "),so=l(it,"CODE",{});var Oh=n(so);Ul=s(Oh,"WHERE"),Oh.forEach(o),Yl=s(it," clause."),it.forEach(o),Na=c(e),u=l(e,"P",{});var b=n(u);Jl=s(b,"Although adding "),io=l(b,"CODE",{});var Ih=n(io);Ql=s(Ih,"ASC"),Ih.forEach(o),Vl=s(b,"/"),lo=l(b,"CODE",{});var Rh=n(lo);Kl=s(Rh,"DESC"),Rh.forEach(o),Xl=s(b,` homogeneously to all sorting columns can take advantage of the same index (due to double linked list being able to traverse both directions),
`),B=l(b,"EM",{});var lt=n(B);Zl=s(lt,"mixing "),no=l(lt,"CODE",{});var Sh=n(no);$l=s(Sh,"ASC"),Sh.forEach(o),en=s(lt," and "),ro=l(lt,"CODE",{});var Ph=n(ro);tn=s(Ph,"DESC"),Ph.forEach(o),on=s(lt," will prevent the use of the original index as it will result in a different in ordering between the query and index"),lt.forEach(o),an=s(b,`.
For example, `),ho=l(b,"CODE",{});var Ch=n(ho);sn=s(Ch,"ORDER BY date_col ASC, product_id ASC"),Ch.forEach(o),ln=s(b," and "),co=l(b,"CODE",{});var qh=n(co);nn=s(qh,"ORDER BY date_col DESC, product_id DESC"),qh.forEach(o),rn=s(b," can use the same index, but "),po=l(b,"CODE",{});var Ah=n(po);dn=s(Ah,"ORDER BY date_col ASC, product_id DESC"),Ah.forEach(o),hn=s(b," will "),uo=l(b,"EM",{});var Lh=n(uo);cn=s(Lh,"not"),Lh.forEach(o),pn=s(b," be able to use the same index!"),b.forEach(o),Ha=c(e),We=l(e,"P",{});var Nh=n(We);un=s(Nh,"It is also important to note that, for large queries, full table scan + sorting may actually be faster than accesing table rows through index due to the \u201Crandom IO\u201D nature of accessing table rows."),Nh.forEach(o),Wa=c(e),Be=l(e,"H2",{});var Hh=n(Be);fn=s(Hh,"GROUP BY"),Hh.forEach(o),Ba=c(e),ne=l(e,"P",{});var id=n(ne);fo=l(id,"CODE",{});var Wh=n(fo);mn=s(Wh,"GROUP BY"),Wh.forEach(o),En=s(id,` has 2 main algorithms: Hash Table algorithm and Sort/Group algorithm.
Hash Table algorithm stores a (temporary) hash table with grouping column as keys, then aggregates that inputs into this hash table.
Sort/Group algorithm sorts the inputs by grouping column, then aggregates the sorted input.`),id.forEach(o),za=c(e),ze=l(e,"P",{});var Bh=n(ze);bn=s(Bh,"Notice that although both needs to materialise an intermediate state, but Hash Table\u2019s memory footprint is way smaller than Sort/Group\u2019s sorted input, therefore usually optimizer prefers Hash Table algo."),Bh.forEach(o),Fa=c(e),K=l(e,"P",{});var gs=n(K);yn=s(gs,"Only the Sort/Group algorithm can make use of index to optmize its performance, and the advantage it has over Hash Table algo is that it enables "),mo=l(gs,"EM",{});var zh=n(mo);vn=s(zh,"pipelined execution"),zh.forEach(o),wn=s(gs," of the query."),gs.forEach(o),Ma=c(e),Fe=l(e,"H2",{});var Fh=n(Fe);xn=s(Fh,"Partial Results"),Fh.forEach(o),Ga=c(e),X=l(e,"P",{});var Ds=n(X);_n=s(Ds,"Indexes enables pipelined "),Eo=l(Ds,"CODE",{});var Mh=n(Eo);Tn=s(Mh,"ORDER BY"),Mh.forEach(o),gn=s(Ds," execution, which optimizes pagination queries by returning results without needing to read the entire table."),Ds.forEach(o),ja=c(e),v=l(e,"P",{});var C=n(v);Dn=s(C,"Therefore, for queries that require partial results (e.g. fetch first 10 IDs), indexing all "),bo=l(C,"CODE",{});var Gh=n(bo);kn=s(Gh,"ORDER BY"),Gh.forEach(o),On=s(C,` columns enables pipelining and therefore greatly reduces latency of the query.
The database will stop execution and return as soon as it has found the required number of rows.
For \u201CTop N\u201D queries, this means that response time of pipelined \u201CTop N\u201D queries grows with number of rows `),yo=l(C,"STRONG",{});var jh=n(yo);In=s(jh,"selected"),jh.forEach(o),Rn=s(C,` instead of table size!
\u201CTop N\u201D queries can be done using `),vo=l(C,"CODE",{});var Uh=n(vo);Sn=s(Uh,"LIMIT"),Uh.forEach(o),Pn=s(C," or "),wo=l(C,"CODE",{});var Yh=n(wo);Cn=s(Yh,"FETCH FIRST N ROWS"),Yh.forEach(o),qn=s(C," clause."),C.forEach(o),Ua=c(e),m=l(e,"P",{});var T=n(m);An=s(T,`For paging through the next N results, there are actually two ways to do this.
The normal way is to add the `),xo=l(T,"CODE",{});var Jh=n(xo);Ln=s(Jh,"OFFSET"),Jh.forEach(o),Nn=s(T," extension clause into the "),_o=l(T,"CODE",{});var Qh=n(_o);Hn=s(Qh,"LIMIT"),Qh.forEach(o),Wn=s(T,"/"),To=l(T,"CODE",{});var Vh=n(To);Bn=s(Vh,"FETCH FIRST"),Vh.forEach(o),zn=s(T,` clauses.
However there are 2 disadvantages to this:
the query results will \u201Cdrift\u201D if there were inserts;
and the query actually `),go=l(T,"EM",{});var Kh=n(go);Fn=s(Kh,"slows"),Kh.forEach(o),Mn=s(T," down the further "),Do=l(T,"CODE",{});var Xh=n(Do);Gn=s(Xh,"OFFSET"),Xh.forEach(o),jn=s(T," you put, since the database has to scan and count the index before returning the desired rows."),T.forEach(o),Ya=c(e),w=l(e,"P",{});var q=n(w);Un=s(q,"The other method is to use "),ko=l(q,"CODE",{});var Zh=n(ko);Yn=s(Zh,"WHERE"),Zh.forEach(o),Jn=s(q,` clause on the last fetched row of the previous page. This will have big performance benefit since it uses tree traversal to find the relevant rows to skip.
To implement this, it is possible to use `),re=l(q,"A",{href:!0,rel:!0});var $h=n(re);Qn=s($h,"row value comparison"),$h.forEach(o),Vn=s(q," if supported by your database, "),Oo=l(q,"CODE",{});var ec=n(Oo);Kn=s(ec,"WHERE (sale_date, sale_id) < (?, ?)"),ec.forEach(o),Xn=s(q,`, as the logic matches the sorting logic.
If not, it is possible, but less efficient, to do normal comparisons, `),Io=l(q,"CODE",{});var tc=n(Io);Zn=s(tc,"WHERE sale_date <= ? AND NOT (sale_date = ? AND sale_id >= ?)"),tc.forEach(o),$n=s(q,`.
This method\u2019s disadvantage is that you are not able to \u201Cjump\u201D straight to page N, since you require the previous page\u2019s last value. But it is still good for \u2018infinite scrolling\u2019 pages.`),q.forEach(o),Ja=c(e),Z=l(e,"P",{});var ks=n(Z);er=s(ks,"For more detailed explanation, do read through the original article at "),de=l(ks,"A",{href:!0,rel:!0});var oc=n(de);tr=s(oc,"use the index luke"),oc.forEach(o),or=s(ks,"."),ks.forEach(o),Qa=c(e),Me=l(e,"H2",{});var ac=n(Me);ar=s(ac,"INSERT, DELETE, UPDATE"),ac.forEach(o),Va=c(e),_=l(e,"P",{});var te=n(_);sr=s(te,`Since indexes are purely redundant/duplicate data that exists on top of the actual table\u2019s data, this requires compute time to keep both indexes and table in sync, as well as maintain the underlying index data structure.
Therefore, the performance of `),Ro=l(te,"CODE",{});var sc=n(Ro);ir=s(sc,"INSERT"),sc.forEach(o),lr=s(te,", "),So=l(te,"CODE",{});var ic=n(So);nr=s(ic,"DELETE"),ic.forEach(o),rr=s(te," and "),Po=l(te,"CODE",{});var lc=n(Po);dr=s(lc,"UPDATE"),lc.forEach(o),hr=s(te," all degrade proportionally to the number of indexes the table has."),te.forEach(o),Ka=c(e),R=l(e,"P",{});var nt=n(R);cr=s(nt,"For "),Co=l(nt,"CODE",{});var nc=n(Co);pr=s(nc,"INSERT"),nc.forEach(o),ur=s(nt,"s, it is important to note that the "),qo=l(nt,"EM",{});var rc=n(qo);fr=s(rc,"first index, i.e. going from 0 to 1 index, makes the greatest difference in performance"),rc.forEach(o),mr=s(nt,` (several orders of magnitude more degradation, compared to adding more indexes when you already have one).
This property can be useful when you are bulk loading large amounts of data, which you can temporarily drop the index to load much faster.`),nt.forEach(o),Xa=c(e),E=l(e,"P",{});var g=n(E);Er=s(g,"For "),Ao=l(g,"CODE",{});var dc=n(Ao);br=s(dc,"DELETE"),dc.forEach(o),yr=s(g,"s, the execution acts like "),Lo=l(g,"CODE",{});var hc=n(Lo);vr=s(hc,"SELECT"),hc.forEach(o),wr=s(g,` with extra delete step at the end.
Hence `),No=l(g,"CODE",{});var cc=n(No);xr=s(cc,"DELETE"),cc.forEach(o),_r=s(g,"ing a single row with no index does not gain the same speed up as "),Ho=l(g,"CODE",{});var pc=n(Ho);Tr=s(pc,"INSERT"),pc.forEach(o),gr=s(g," (as it requires full table scan), but it may still make sense when "),Wo=l(g,"CODE",{});var uc=n(Wo);Dr=s(uc,"DELETE"),uc.forEach(o),kr=s(g,"ing many rows."),g.forEach(o),Za=c(e),x=l(e,"P",{});var A=n(x);Or=s(A,"For "),Bo=l(A,"CODE",{});var fc=n(Bo);Ir=s(fc,"UPDATE"),fc.forEach(o),Rr=s(A,"s, the execution acts like a "),zo=l(A,"CODE",{});var mc=n(zo);Sr=s(mc,"DELETE"),mc.forEach(o),Pr=s(A," + "),Fo=l(A,"CODE",{});var Ec=n(Fo);Cr=s(Ec,"INSERT"),Ec.forEach(o),qr=s(A," operation. The important thing about "),Mo=l(A,"CODE",{});var bc=n(Mo);Ar=s(bc,"UPDATE"),bc.forEach(o),Lr=s(A,`s is that changed values/columns may not be present in all indexes, therefore it is important to only update the columns that needs updating.
This might not apply when writing the SQL manually, but when using ORM tools this could be a hidden performance trap if not careful.`),A.forEach(o),$a=c(e),Ge=l(e,"H2",{});var yc=n(Ge);Nr=s(yc,"Glossary"),yc.forEach(o),es=c(e),je=l(e,"P",{});var vc=n(je);Go=l(vc,"STRONG",{});var wc=n(Go);Hr=s(wc,"Pipelining"),wc.forEach(o),vc.forEach(o),ts=c(e),$=l(e,"P",{});var Os=n($);Wr=s(Os,`Pipelining / Pipelined Execution is a way in which database executes the operations from the query plan.
Pipelined Execution works \u201Crow-by-row\u201D and passes the row/tuple to the next operation immediately after the current operation is done.
Pipelined execution is advantageous because it reduces response time of your query, especially for `),jo=l(Os,"CODE",{});var xc=n(jo);Br=s(xc,"LIMIT"),xc.forEach(o),zr=s(Os," type queries."),Os.forEach(o),os=c(e),Ue=l(e,"P",{});var _c=n(Ue);Fr=s(_c,`This is in contrast to another way of execution (Materlisation Execution Model), which is to wait for the entire intermediate output to materialise, then pass on to the next operation.
A similar analogy is the difference between stream processing vs batch processing.`),_c.forEach(o),as=c(e),Ye=l(e,"P",{});var Tc=n(Ye);Mr=s(Tc,`OLAP databases also take pipelining one step further and implements Vectorized Execution. In Vectorized Execution, instead of returning \u201Crow-by-row\u201D, the operator returns \u201Cbatch-by-batch\u201D, i.e. small batches of rows instead of a single row.
This greatly reduces number of CPU cycles needed per operator, and also allows operators to take advantage of CPU\u2019s SIMD instructions (Single Instruction Multiple Data) to speed up the query.`),Tc.forEach(o),ss=c(e),Je=l(e,"P",{});var gc=n(Je);Uo=l(gc,"STRONG",{});var Dc=n(Uo);Gr=s(Dc,"Clustering Factor"),Dc.forEach(o),gc.forEach(o),is=c(e),ee=l(e,"P",{});var Is=n(ee);jr=s(Is,`Clustering factor is how correlated the sequence of the column\u2019s data values are to the sequence of their physical order.
In Oracle, the clustering factor value is `),Yo=l(Is,"EM",{});var kc=n(Yo);Ur=s(kc,"low"),kc.forEach(o),Yr=s(Is,` when the sequences are correlated.
While in Postgres, they use actual Pearson correlation, so when value is 0 is totally uncorrelated and when value is 1 (or -1) they are totally correlated.`),Is.forEach(o),ls=c(e),Qe=l(e,"P",{});var Oc=n(Qe);Jo=l(Oc,"STRONG",{});var Ic=n(Jo);Jr=s(Ic,"Prepared Statements/Bind Parameters"),Ic.forEach(o),Oc.forEach(o),ns=c(e),Ve=l(e,"P",{});var Rc=n(Ve);Qr=s(Rc,"Prepared statements are SQL template statements which have placeholders in certain clauses that can be filled on the next run."),Rc.forEach(o),rs=c(e),Ke=l(e,"P",{});var Sc=n(Ke);Vr=s(Sc,"For example:"),Sc.forEach(o),ds=c(e),he=l(e,"PRE",{class:!0});var Hc=n(he);Hc.forEach(o),hs=c(e),S=l(e,"P",{});var rt=n(S);Kr=s(rt,"The above statement is a prepared statement as there are "),Qo=l(rt,"CODE",{});var Pc=n(Qo);Xr=s(Pc,"?"),Pc.forEach(o),Zr=s(rt," in the "),Vo=l(rt,"CODE",{});var Cc=n(Vo);$r=s(Cc,"WHERE"),Cc.forEach(o),ed=s(rt," clause. Actual values will be sent by the application to the database on the subsequent calls to this prepared statement."),rt.forEach(o),cs=c(e),Xe=l(e,"P",{});var qc=n(Xe);td=s(qc,"Prepared statements are highly recommended because it prevents SQL injection attacks. It also prevents re-run of query optimizer everytime the query is sent to the database, this reduces latency since the database can re-use the same query plan for this prepared statement, which is especially important for complex queries!"),qc.forEach(o),this.h()},h(){ce(oe,"href","https://use-the-index-luke.com/"),ce(oe,"rel","nofollow"),ce(re,"href","https://www.postgresql.org/docs/current/functions-comparisons.html#ROW-WISE-COMPARISON"),ce(re,"rel","nofollow"),ce(de,"href","https://use-the-index-luke.com/sql/partial-results/fetch-next-page"),ce(de,"rel","nofollow"),ce(he,"class","language-sql")},m(e,r){d(e,z,r),t(z,Rs),d(e,Ko,r),d(e,F,r),t(F,Ss),t(F,oe),t(oe,Ps),t(F,Cs),d(e,Xo,r),d(e,pe,r),t(pe,qs),d(e,Zo,r),d(e,D,r),t(D,dt),t(dt,As),t(D,Ls),t(D,ht),t(ht,Ns),t(D,Hs),t(D,ct),t(ct,Ws),d(e,$o,r),d(e,ue,r),t(ue,Bs),d(e,ea,r),d(e,fe,r),t(fe,pt),t(pt,zs),d(e,ta,r),d(e,me,r),t(me,Fs),d(e,oa,r),d(e,Ee,r),t(Ee,ut),t(ut,Ms),d(e,aa,r),d(e,M,r),t(M,Gs),t(M,ft),t(ft,js),t(M,Us),d(e,sa,r),d(e,be,r),t(be,mt),t(mt,Ys),d(e,ia,r),d(e,ye,r),t(ye,Js),d(e,la,r),d(e,y,r),t(y,Qs),t(y,Et),t(Et,Vs),t(y,Ks),t(y,bt),t(bt,Xs),t(y,Zs),t(y,yt),t(yt,$s),t(y,ei),t(y,vt),t(vt,ti),t(y,oi),d(e,na,r),d(e,ve,r),t(ve,wt),t(wt,ai),d(e,ra,r),d(e,G,r),t(G,si),t(G,xt),t(xt,ii),t(G,li),d(e,da,r),d(e,we,r),t(we,_t),t(_t,ni),d(e,ha,r),d(e,xe,r),t(xe,ri),d(e,ca,r),d(e,k,r),t(k,Tt),t(Tt,di),t(k,hi),t(k,gt),t(gt,ci),t(k,pi),t(k,ae),t(ae,ui),t(ae,Dt),t(Dt,fi),t(ae,mi),d(e,pa,r),d(e,_e,r),t(_e,Ei),d(e,ua,r),d(e,se,r),t(se,kt),t(kt,bi),t(se,yi),d(e,fa,r),d(e,j,r),t(j,vi),t(j,Ot),t(Ot,wi),t(j,xi),d(e,ma,r),d(e,p,r),t(p,It),t(It,_i),t(p,Ti),t(p,Rt),t(Rt,gi),t(p,Di),t(p,Te),t(Te,ki),t(Te,St),t(St,L),t(L,Oi),t(L,Pt),t(Pt,Ii),t(L,Ri),t(L,Ct),t(Ct,Si),t(L,Pi),t(p,Ci),t(p,qt),t(qt,qi),t(p,Ai),t(p,N),t(N,Li),t(N,At),t(At,Ni),t(N,Hi),t(N,Lt),t(Lt,Wi),t(N,Bi),t(p,zi),t(p,H),t(H,Fi),t(H,Nt),t(Nt,Mi),t(H,Gi),t(H,Ht),t(Ht,ji),t(H,Ui),t(p,Yi),t(p,W),t(W,Ji),t(W,Wt),t(Wt,Qi),t(W,Vi),t(W,Bt),t(Bt,Ki),t(W,Xi),t(p,Zi),t(p,ge),t(ge,$i),t(ge,ie),t(ie,zt),t(zt,el),t(ie,tl),t(ie,le),t(le,ol),t(le,Ft),t(Ft,al),t(le,sl),t(p,il),t(p,Mt),t(Mt,ll),t(p,nl),t(p,Gt),t(Gt,rl),d(e,Ea,r),d(e,De,r),t(De,dl),d(e,ba,r),d(e,U,r),t(U,hl),t(U,jt),t(jt,cl),t(U,pl),d(e,ya,r),d(e,Y,r),t(Y,ul),t(Y,Ut),t(Ut,fl),t(Y,ml),d(e,va,r),d(e,ke,r),t(ke,Yt),t(Yt,El),d(e,wa,r),d(e,Oe,r),t(Oe,bl),d(e,xa,r),d(e,Ie,r),t(Ie,Jt),t(Jt,yl),d(e,_a,r),d(e,O,r),t(O,vl),t(O,Qt),t(Qt,wl),t(O,xl),t(O,Vt),t(Vt,_l),t(O,Tl),d(e,Ta,r),d(e,Re,r),t(Re,Kt),t(Kt,gl),d(e,ga,r),d(e,J,r),t(J,Dl),t(J,Xt),t(Xt,kl),t(J,Ol),d(e,Da,r),d(e,Se,r),t(Se,Il),d(e,ka,r),d(e,Pe,r),t(Pe,Rl),d(e,Oa,r),d(e,Ce,r),t(Ce,Zt),t(Zt,Sl),d(e,Ia,r),d(e,qe,r),t(qe,Pl),d(e,Ra,r),d(e,Ae,r),t(Ae,$t),t($t,Cl),d(e,Sa,r),d(e,Q,r),t(Q,ql),t(Q,eo),t(eo,Al),t(Q,Ll),d(e,Pa,r),d(e,V,r),t(V,Nl),t(V,to),t(to,Hl),t(V,Wl),d(e,Ca,r),d(e,Le,r),t(Le,oo),t(oo,Bl),d(e,qa,r),d(e,Ne,r),t(Ne,zl),d(e,Aa,r),d(e,He,r),t(He,Fl),d(e,La,r),d(e,I,r),t(I,Ml),t(I,ao),t(ao,Gl),t(I,jl),t(I,so),t(so,Ul),t(I,Yl),d(e,Na,r),d(e,u,r),t(u,Jl),t(u,io),t(io,Ql),t(u,Vl),t(u,lo),t(lo,Kl),t(u,Xl),t(u,B),t(B,Zl),t(B,no),t(no,$l),t(B,en),t(B,ro),t(ro,tn),t(B,on),t(u,an),t(u,ho),t(ho,sn),t(u,ln),t(u,co),t(co,nn),t(u,rn),t(u,po),t(po,dn),t(u,hn),t(u,uo),t(uo,cn),t(u,pn),d(e,Ha,r),d(e,We,r),t(We,un),d(e,Wa,r),d(e,Be,r),t(Be,fn),d(e,Ba,r),d(e,ne,r),t(ne,fo),t(fo,mn),t(ne,En),d(e,za,r),d(e,ze,r),t(ze,bn),d(e,Fa,r),d(e,K,r),t(K,yn),t(K,mo),t(mo,vn),t(K,wn),d(e,Ma,r),d(e,Fe,r),t(Fe,xn),d(e,Ga,r),d(e,X,r),t(X,_n),t(X,Eo),t(Eo,Tn),t(X,gn),d(e,ja,r),d(e,v,r),t(v,Dn),t(v,bo),t(bo,kn),t(v,On),t(v,yo),t(yo,In),t(v,Rn),t(v,vo),t(vo,Sn),t(v,Pn),t(v,wo),t(wo,Cn),t(v,qn),d(e,Ua,r),d(e,m,r),t(m,An),t(m,xo),t(xo,Ln),t(m,Nn),t(m,_o),t(_o,Hn),t(m,Wn),t(m,To),t(To,Bn),t(m,zn),t(m,go),t(go,Fn),t(m,Mn),t(m,Do),t(Do,Gn),t(m,jn),d(e,Ya,r),d(e,w,r),t(w,Un),t(w,ko),t(ko,Yn),t(w,Jn),t(w,re),t(re,Qn),t(w,Vn),t(w,Oo),t(Oo,Kn),t(w,Xn),t(w,Io),t(Io,Zn),t(w,$n),d(e,Ja,r),d(e,Z,r),t(Z,er),t(Z,de),t(de,tr),t(Z,or),d(e,Qa,r),d(e,Me,r),t(Me,ar),d(e,Va,r),d(e,_,r),t(_,sr),t(_,Ro),t(Ro,ir),t(_,lr),t(_,So),t(So,nr),t(_,rr),t(_,Po),t(Po,dr),t(_,hr),d(e,Ka,r),d(e,R,r),t(R,cr),t(R,Co),t(Co,pr),t(R,ur),t(R,qo),t(qo,fr),t(R,mr),d(e,Xa,r),d(e,E,r),t(E,Er),t(E,Ao),t(Ao,br),t(E,yr),t(E,Lo),t(Lo,vr),t(E,wr),t(E,No),t(No,xr),t(E,_r),t(E,Ho),t(Ho,Tr),t(E,gr),t(E,Wo),t(Wo,Dr),t(E,kr),d(e,Za,r),d(e,x,r),t(x,Or),t(x,Bo),t(Bo,Ir),t(x,Rr),t(x,zo),t(zo,Sr),t(x,Pr),t(x,Fo),t(Fo,Cr),t(x,qr),t(x,Mo),t(Mo,Ar),t(x,Lr),d(e,$a,r),d(e,Ge,r),t(Ge,Nr),d(e,es,r),d(e,je,r),t(je,Go),t(Go,Hr),d(e,ts,r),d(e,$,r),t($,Wr),t($,jo),t(jo,Br),t($,zr),d(e,os,r),d(e,Ue,r),t(Ue,Fr),d(e,as,r),d(e,Ye,r),t(Ye,Mr),d(e,ss,r),d(e,Je,r),t(Je,Uo),t(Uo,Gr),d(e,is,r),d(e,ee,r),t(ee,jr),t(ee,Yo),t(Yo,Ur),t(ee,Yr),d(e,ls,r),d(e,Qe,r),t(Qe,Jo),t(Jo,Jr),d(e,ns,r),d(e,Ve,r),t(Ve,Qr),d(e,rs,r),d(e,Ke,r),t(Ke,Vr),d(e,ds,r),d(e,he,r),he.innerHTML=Nc,d(e,hs,r),d(e,S,r),t(S,Kr),t(S,Qo),t(Qo,Xr),t(S,Zr),t(S,Vo),t(Vo,$r),t(S,ed),d(e,cs,r),d(e,Xe,r),t(Xe,td)},p:ld,i:ld,o:ld,d(e){e&&o(z),e&&o(Ko),e&&o(F),e&&o(Xo),e&&o(pe),e&&o(Zo),e&&o(D),e&&o($o),e&&o(ue),e&&o(ea),e&&o(fe),e&&o(ta),e&&o(me),e&&o(oa),e&&o(Ee),e&&o(aa),e&&o(M),e&&o(sa),e&&o(be),e&&o(ia),e&&o(ye),e&&o(la),e&&o(y),e&&o(na),e&&o(ve),e&&o(ra),e&&o(G),e&&o(da),e&&o(we),e&&o(ha),e&&o(xe),e&&o(ca),e&&o(k),e&&o(pa),e&&o(_e),e&&o(ua),e&&o(se),e&&o(fa),e&&o(j),e&&o(ma),e&&o(p),e&&o(Ea),e&&o(De),e&&o(ba),e&&o(U),e&&o(ya),e&&o(Y),e&&o(va),e&&o(ke),e&&o(wa),e&&o(Oe),e&&o(xa),e&&o(Ie),e&&o(_a),e&&o(O),e&&o(Ta),e&&o(Re),e&&o(ga),e&&o(J),e&&o(Da),e&&o(Se),e&&o(ka),e&&o(Pe),e&&o(Oa),e&&o(Ce),e&&o(Ia),e&&o(qe),e&&o(Ra),e&&o(Ae),e&&o(Sa),e&&o(Q),e&&o(Pa),e&&o(V),e&&o(Ca),e&&o(Le),e&&o(qa),e&&o(Ne),e&&o(Aa),e&&o(He),e&&o(La),e&&o(I),e&&o(Na),e&&o(u),e&&o(Ha),e&&o(We),e&&o(Wa),e&&o(Be),e&&o(Ba),e&&o(ne),e&&o(za),e&&o(ze),e&&o(Fa),e&&o(K),e&&o(Ma),e&&o(Fe),e&&o(Ga),e&&o(X),e&&o(ja),e&&o(v),e&&o(Ua),e&&o(m),e&&o(Ya),e&&o(w),e&&o(Ja),e&&o(Z),e&&o(Qa),e&&o(Me),e&&o(Va),e&&o(_),e&&o(Ka),e&&o(R),e&&o(Xa),e&&o(E),e&&o(Za),e&&o(x),e&&o($a),e&&o(Ge),e&&o(es),e&&o(je),e&&o(ts),e&&o($),e&&o(os),e&&o(Ue),e&&o(as),e&&o(Ye),e&&o(ss),e&&o(Je),e&&o(is),e&&o(ee),e&&o(ls),e&&o(Qe),e&&o(ns),e&&o(Ve),e&&o(rs),e&&o(Ke),e&&o(ds),e&&o(he),e&&o(hs),e&&o(S),e&&o(cs),e&&o(Xe)}}}const Mc={title:"Database Indexes and Query Optimization",date:"2023-06-07"},{title:Ac,date:jc}=Mc;class Uc extends Wc{constructor(z){super(),Bc(this,z,null,Fc,zc,{})}}export{Uc as default,Mc as metadata};
