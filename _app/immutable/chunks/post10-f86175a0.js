import{S as po,i as lo,s as io,k as o,q as n,a as r,l as p,m as l,r as t,h as s,c as u,n as y,b as c,B as a,A as Bn}from"./index-4cbca6b4.js";function co(Kt){let O,Na,Xe,J,Fa,Ye,K,Ma,Ze,_,Wa,he,za,ja,ke,Ba,Ga,$e,Q,Ja,ea,T,Qt=`<code class="language-py">df <span class="token operator">=</span> pd<span class="token punctuation">.</span>DataFrame<span class="token punctuation">(</span><span class="token punctuation">&#123;</span>
	<span class="token string">'name'</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">,</span><span class="token string">'b'</span><span class="token punctuation">,</span><span class="token string">'c'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
	<span class="token string">'age'</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token number">25</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">,</span> <span class="token number">99</span><span class="token punctuation">]</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">)</span></code>`,aa,V,Ka,sa,A,Vt='<code class="language-py">df<span class="token punctuation">[</span>df<span class="token punctuation">.</span>age <span class="token operator">&lt;=</span><span class="token number">30</span><span class="token punctuation">]</span></code>',na,X,Qa,ta,H,Xt=`<code class="language-py">df<span class="token punctuation">[</span><span class="token string">'new_col'</span><span class="token punctuation">]</span> <span class="token operator">=</span> df<span class="token punctuation">.</span>age <span class="token operator">+</span> <span class="token number">30</span></code>`,oa,Y,Va,pa,I,Yt=`<code class="language-py">df2 <span class="token operator">=</span> df<span class="token punctuation">[</span>df<span class="token punctuation">.</span>age <span class="token operator">&lt;=</span> <span class="token number">30</span><span class="token punctuation">]</span> <span class="token comment"># does not change df in-place?</span>
df2<span class="token punctuation">[</span><span class="token string">'new_col'</span><span class="token punctuation">]</span> <span class="token operator">=</span> df2<span class="token punctuation">.</span>age <span class="token operator">+</span> <span class="token number">30</span> <span class="token comment"># changes df2 in-place?</span></code>`,la,Z,Xa,ia,E,Ya,ve,Za,$a,ye,es,as,ca,L,Zt=`<code class="language-py">df<span class="token punctuation">.</span>query<span class="token punctuation">(</span>
	<span class="token string">'age &lt;= 30'</span>
<span class="token punctuation">)</span><span class="token punctuation">.</span>assign<span class="token punctuation">(</span>
	new_col <span class="token operator">=</span> <span class="token keyword">lambda</span> x<span class="token punctuation">:</span> x<span class="token punctuation">[</span><span class="token string">'age'</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">20</span>
<span class="token punctuation">)</span><span class="token punctuation">.</span>query<span class="token punctuation">(</span>
	<span class="token string">'new_col >= 50'</span>
<span class="token punctuation">)</span></code>`,ra,b,ss,we,ns,ts,_e,os,ps,ua,S,ls,Ee,is,cs,da,d,rs,be,us,ds,ge,fs,ms,Pe,hs,ks,Ce,vs,ys,De,ws,_s,Oe,Es,bs,Se,gs,Ps,xe,Cs,Ds,fa,$,Os,ma,ee,Ss,ha,ae,xs,ka,h,Ts,Te,As,Hs,Ae,Is,Ls,He,Rs,qs,Ie,Us,Ns,va,se,Fs,ya,g,R,Ms,Le,Ws,zs,js,q,Bs,Re,Gs,Js,Ks,U,Qs,qe,Vs,Xs,wa,w,Ys,Ue,Zs,$s,Ne,en,an,Fe,sn,_a,ne,nn,Ea,m,tn,Me,on,pn,We,ln,cn,ze,rn,un,je,dn,fn,Be,mn,hn,ba,te,kn,ga,P,N,vn,Ge,yn,wn,_n,F,En,Je,bn,gn,Pn,M,Cn,Ke,Dn,On,Pa,oe,Sn,Ca,C,xn,Qe,Tn,An,Ve,Hn,In,Da,pe,Ln,Oa,le,Rn,Sa,k,qn,W,Un,Nn,z,Fn,Mn,j,Wn,zn,xa,ie,jn,Ta,B,$t=`<code class="language-python">df <span class="token operator">=</span> pd<span class="token punctuation">.</span>DataFrame<span class="token punctuation">(</span><span class="token punctuation">&#123;</span>
	<span class="token string">'name'</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">,</span><span class="token string">'b'</span><span class="token punctuation">,</span><span class="token string">'c'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
	<span class="token string">'age'</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token number">25</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">,</span> <span class="token number">99</span><span class="token punctuation">]</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">)</span>

<span class="token comment"># nest the lambdas so this funciton is usable within .assign()</span>
<span class="token keyword">def</span> <span class="token function">to_uppercase</span><span class="token punctuation">(</span>col_name<span class="token punctuation">)</span><span class="token punctuation">:</span>
	<span class="token keyword">return</span> <span class="token keyword">lambda</span> dataframe<span class="token punctuation">:</span> dataframe<span class="token punctuation">[</span>col_name<span class="token punctuation">]</span><span class="token punctuation">.</span>pipe<span class="token punctuation">(</span><span class="token keyword">lambda</span> x<span class="token punctuation">:</span> <span class="token string">'Using element wise map: '</span> <span class="token operator">+</span> x<span class="token punctuation">.</span>upper<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token comment"># abstract out inner function</span>
<span class="token comment"># multiple inner functions can then be reused/chained</span>
<span class="token keyword">def</span> <span class="token function">series_transform_string</span><span class="token punctuation">(</span>x<span class="token punctuation">:</span> pd<span class="token punctuation">.</span>Series<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> pd<span class="token punctuation">.</span>Series<span class="token punctuation">:</span>
    <span class="token keyword">return</span> <span class="token string">'Using vectorised pipe: '</span> <span class="token operator">+</span> x<span class="token punctuation">.</span><span class="token builtin">str</span><span class="token punctuation">.</span>upper<span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token comment"># similar as first example, but inner lambda is abstracted out</span>
<span class="token keyword">def</span> <span class="token function">to_uppercase2</span><span class="token punctuation">(</span>col_name<span class="token punctuation">)</span><span class="token punctuation">:</span>
	<span class="token keyword">return</span> <span class="token keyword">lambda</span> dataframe<span class="token punctuation">:</span> dataframe<span class="token punctuation">[</span>col_name<span class="token punctuation">]</span><span class="token punctuation">.</span>pipe<span class="token punctuation">(</span>series_transform_string<span class="token punctuation">)</span>

df<span class="token punctuation">.</span>assign<span class="token punctuation">(</span>
	more_than_seventy <span class="token operator">=</span> <span class="token keyword">lambda</span> d<span class="token punctuation">:</span> d<span class="token punctuation">[</span><span class="token string">'age'</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token builtin">map</span><span class="token punctuation">(</span><span class="token keyword">lambda</span> age<span class="token punctuation">:</span> <span class="token boolean">True</span> <span class="token keyword">if</span> age <span class="token operator">></span> <span class="token number">70</span> <span class="token keyword">else</span> <span class="token boolean">False</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
	uppercase_name <span class="token operator">=</span> to_uppercase<span class="token punctuation">(</span><span class="token string">'name'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    another_upper <span class="token operator">=</span> to_uppercase2<span class="token punctuation">(</span><span class="token string">'name'</span><span class="token punctuation">)</span>
<span class="token punctuation">)</span></code>`;return{c(){O=o("h1"),Na=n(Jt),Xe=r(),J=o("p"),Fa=n("In this post, I explore possible ways to write Pandas code in hopes of makign Pandas code more readable, composable, reusable, and testable."),Ye=r(),K=o("h2"),Ma=n("motivation"),Ze=r(),_=o("p"),Wa=n("After using R\u2019s "),he=o("code"),za=n("dplyr"),ja=n(" (and the entire "),ke=o("code"),Ba=n("tidyverse"),Ga=n(` ecosystem) to manipulate dataframes for awhile, Panda\u2019s API feels clunky in comparison.
The main issue seems to be difficulty in chaining and composing operations.
This tends to cause Pandas code to go against good software design principles, because it is difficult to break down larger chain of operations and also difficult to stitch smaller operations together.
This has an added effect of making tests hard to write, as user written Pandas functions are often doing a lot of things at once.`),$e=r(),Q=o("h2"),Ja=n("Concrete example of the issue"),ea=r(),T=o("pre"),aa=r(),V=o("p"),Ka=n("A common way to filter the rows of dataframe is:"),sa=r(),A=o("pre"),na=r(),X=o("p"),Qa=n("And a common way to assign a new column to the dataframe is:"),ta=r(),H=o("pre"),oa=r(),Y=o("p"),Va=n(`Now with the above two operations, how does one chain those two simple operations together?
We will probably have to keep assigning intermediate dataframe variables, which gets clunky after awhile:`),pa=r(),I=o("pre"),la=r(),Z=o("h2"),Xa=n(".assign and .query"),ia=r(),E=o("p"),Ya=n("A more chainable way to do filters and add calculated columns is to use "),ve=o("code"),Za=n(".query()"),$a=n(" and "),ye=o("code"),es=n(".assign()"),as=n(" methods:"),ca=r(),L=o("pre"),ra=r(),b=o("p"),ss=n(`Even though this is better, there are still some drawbacks.
The first is `),we=o("code"),ns=n(".query()"),ts=n(` uses a query string and not native python code,
which means you lose all IDE auto complete capabilities `),_e=o("em"),os=n("(\u2018what columns do my dataframe have again?\u2018)"),ps=n("."),ua=r(),S=o("p"),ls=n("The second is that using "),Ee=o("code"),is=n("assign"),cs=n(` fixes the column names that the lambda function operates on,
unless you introduce another layer of abstraction to parameterise the lambda function.
This second point is important when you want to reuse this function across different dataframes.
This is seems to be caused by the next point.`),da=r(),d=o("p"),rs=n("The third point is the un-intuitiveness of the LHS and RHS of the expressions in "),be=o("code"),us=n(".assign()"),ds=n(`\u2019s arguments.
One would expect that since we are assigning a new `),ge=o("strong"),fs=n("column"),ms=n(" (i.e. a "),Pe=o("code"),hs=n("Series"),ks=n(") called "),Ce=o("code"),vs=n("new_col"),ys=n(" on the LHS, the RHS\u2019 lambda input(s) should be of type "),De=o("code"),ws=n("Series"),_s=n(` as well.
This seems more intuitive because most operations are computations of one or more `),Oe=o("code"),Es=n("Series"),bs=n(` (e.g. total_sales_column = item_price_column * quantity_sold_column).
However this is not the case as the lambda function takes in a `),Se=o("code"),gs=n("DataFrame"),Ps=n(" as input, and expects a "),xe=o("code"),Cs=n("Series"),Ds=n(" as output."),fa=r(),$=o("h1"),Os=n("Chaining methods (.apply, .applymap, .map, .pipe)"),ma=r(),ee=o("p"),Ss=n("There are a variety of (overlapping) chaining methods that we can use, which does not help with implementing chaining as it can be confusing to choose which methods to use."),ha=r(),ae=o("h2"),xs=n("Chaining functions on DataFrames"),ka=r(),h=o("p"),Ts=n("When working with "),Te=o("code"),As=n("DataFrames"),Hs=n(", you have the option of "),Ae=o("code"),Is=n(".pipe"),Ls=n(", "),He=o("code"),Rs=n(".apply"),qs=n(" and "),Ie=o("code"),Us=n(".applymap"),Ns=n(" to chain functions, which is also unintuitive at first glance (which one should I use? they all look like they do the same thing!)."),va=r(),se=o("p"),Fs=n("As a general rule of thumb:"),ya=r(),g=o("ul"),R=o("li"),Ms=n("Default to using "),Le=o("code"),Ws=n(".pipe"),zs=n(", so as to ease cognitive overhead in remembering which specific method to use. If pipe isn\u2019t suitable, try the below methods;"),js=r(),q=o("li"),Bs=n("Use "),Re=o("code"),Gs=n(".applymap"),Js=n(" when you need element-wise operation"),Ks=r(),U=o("li"),Qs=n("Use "),qe=o("code"),Vs=n(".apply"),Xs=n(" when you need to operate on row-wise aggregations/Series"),wa=r(),w=o("p"),Ys=n("However, note that "),Ue=o("code"),Zs=n(".applymap"),$s=n(" and "),Ne=o("code"),en=n(".apply"),an=n(" applies the function to ALL elements/columns/rows, and in order to operate only on certain columns, you would have to do "),Fe=o("code"),sn=n("df['col'].applymap(my_func)"),_a=r(),ne=o("h2"),nn=n("Chaining functions on Series"),Ea=r(),m=o("p"),tn=n("When working with "),Me=o("code"),on=n("Series"),pn=n(", you have the option of "),We=o("code"),ln=n(".pipe"),cn=n(", "),ze=o("code"),rn=n(".apply"),un=n(" and "),je=o("code"),dn=n(".map"),fn=n(". Again, having multiple options that does "),Be=o("em"),mn=n("almost"),hn=n(" the same things can be very confusing."),ba=r(),te=o("p"),kn=n("As a general rule of thumb:"),ga=r(),P=o("ul"),N=o("li"),vn=n("Default to using "),Ge=o("code"),yn=n(".pipe"),wn=n(", so as to ease cognitive overhead in remembering which specific method to use. If pipe isn\u2019t suitable, try the below methods;"),_n=r(),F=o("li"),En=n("Use "),Je=o("code"),bn=n(".map"),gn=n(" when you want to substitute elements using a dictionary (e.g. map \u2018A\u2019 to 1, \u2018B\u2019 to 2, etc.)"),Pn=r(),M=o("li"),Cn=n("Use "),Ke=o("code"),Dn=n(".apply"),On=n(" if you need to use Numpy functions"),Pa=r(),oe=o("h1"),Sn=n("Speed"),Ca=r(),C=o("p"),xn=n("Since most of these chaining methods uses "),Qe=o("em"),Tn=n("Python"),An=n(`\u2019s for-loop in the background, it will NOT take advantage of the machine code vectorization that Pandas (and Numpy) has integrated into its normal \u2018unchained\u2019 API.
These vectorizations (e.g. `),Ve=o("code"),Hn=n("df['x'] / df['y']"),In=n(`) calls Numpy\u2019s underlying C code which helps to improve performance massively.
Hence there is a major trade off in writing (somewhat) more readable code, which is kind of disappointing as we have to trade off developer experience for runtime performance.`),Da=r(),pe=o("h1"),Ln=n("Conclusion and alternatives"),Oa=r(),le=o("p"),Rn=n("It does seem like it is very hard to shoe-horn dplyr\u2019s more intuitive API into pandas\u2019, as they are fundamentally designed very differently."),Sa=r(),k=o("p"),qn=n("Some alternatives that have nicer APIs include R\u2019s "),W=o("a"),Un=n("dplyr"),Nn=n(" as mentioned. If using python, there are also promising alternatives like "),z=o("a"),Fn=n("polars"),Mn=n(" and "),j=o("a"),Wn=n("ibis"),zn=n("."),xa=r(),ie=o("h1"),jn=n("Code examples"),Ta=r(),B=o("pre"),this.h()},l(e){O=p(e,"H1",{});var i=l(O);Na=t(i,Jt),i.forEach(s),Xe=u(e),J=p(e,"P",{});var Gn=l(J);Fa=t(Gn,"In this post, I explore possible ways to write Pandas code in hopes of makign Pandas code more readable, composable, reusable, and testable."),Gn.forEach(s),Ye=u(e),K=p(e,"H2",{});var Jn=l(K);Ma=t(Jn,"motivation"),Jn.forEach(s),Ze=u(e),_=p(e,"P",{});var ce=l(_);Wa=t(ce,"After using R\u2019s "),he=p(ce,"CODE",{});var Kn=l(he);za=t(Kn,"dplyr"),Kn.forEach(s),ja=t(ce," (and the entire "),ke=p(ce,"CODE",{});var Qn=l(ke);Ba=t(Qn,"tidyverse"),Qn.forEach(s),Ga=t(ce,` ecosystem) to manipulate dataframes for awhile, Panda\u2019s API feels clunky in comparison.
The main issue seems to be difficulty in chaining and composing operations.
This tends to cause Pandas code to go against good software design principles, because it is difficult to break down larger chain of operations and also difficult to stitch smaller operations together.
This has an added effect of making tests hard to write, as user written Pandas functions are often doing a lot of things at once.`),ce.forEach(s),$e=u(e),Q=p(e,"H2",{});var Vn=l(Q);Ja=t(Vn,"Concrete example of the issue"),Vn.forEach(s),ea=u(e),T=p(e,"PRE",{class:!0});var eo=l(T);eo.forEach(s),aa=u(e),V=p(e,"P",{});var Xn=l(V);Ka=t(Xn,"A common way to filter the rows of dataframe is:"),Xn.forEach(s),sa=u(e),A=p(e,"PRE",{class:!0});var ao=l(A);ao.forEach(s),na=u(e),X=p(e,"P",{});var Yn=l(X);Qa=t(Yn,"And a common way to assign a new column to the dataframe is:"),Yn.forEach(s),ta=u(e),H=p(e,"PRE",{class:!0});var so=l(H);so.forEach(s),oa=u(e),Y=p(e,"P",{});var Zn=l(Y);Va=t(Zn,`Now with the above two operations, how does one chain those two simple operations together?
We will probably have to keep assigning intermediate dataframe variables, which gets clunky after awhile:`),Zn.forEach(s),pa=u(e),I=p(e,"PRE",{class:!0});var no=l(I);no.forEach(s),la=u(e),Z=p(e,"H2",{});var $n=l(Z);Xa=t($n,".assign and .query"),$n.forEach(s),ia=u(e),E=p(e,"P",{});var re=l(E);Ya=t(re,"A more chainable way to do filters and add calculated columns is to use "),ve=p(re,"CODE",{});var et=l(ve);Za=t(et,".query()"),et.forEach(s),$a=t(re," and "),ye=p(re,"CODE",{});var at=l(ye);es=t(at,".assign()"),at.forEach(s),as=t(re," methods:"),re.forEach(s),ca=u(e),L=p(e,"PRE",{class:!0});var to=l(L);to.forEach(s),ra=u(e),b=p(e,"P",{});var ue=l(b);ss=t(ue,`Even though this is better, there are still some drawbacks.
The first is `),we=p(ue,"CODE",{});var st=l(we);ns=t(st,".query()"),st.forEach(s),ts=t(ue,` uses a query string and not native python code,
which means you lose all IDE auto complete capabilities `),_e=p(ue,"EM",{});var nt=l(_e);os=t(nt,"(\u2018what columns do my dataframe have again?\u2018)"),nt.forEach(s),ps=t(ue,"."),ue.forEach(s),ua=u(e),S=p(e,"P",{});var Aa=l(S);ls=t(Aa,"The second is that using "),Ee=p(Aa,"CODE",{});var tt=l(Ee);is=t(tt,"assign"),tt.forEach(s),cs=t(Aa,` fixes the column names that the lambda function operates on,
unless you introduce another layer of abstraction to parameterise the lambda function.
This second point is important when you want to reuse this function across different dataframes.
This is seems to be caused by the next point.`),Aa.forEach(s),da=u(e),d=p(e,"P",{});var f=l(d);rs=t(f,"The third point is the un-intuitiveness of the LHS and RHS of the expressions in "),be=p(f,"CODE",{});var ot=l(be);us=t(ot,".assign()"),ot.forEach(s),ds=t(f,`\u2019s arguments.
One would expect that since we are assigning a new `),ge=p(f,"STRONG",{});var pt=l(ge);fs=t(pt,"column"),pt.forEach(s),ms=t(f," (i.e. a "),Pe=p(f,"CODE",{});var lt=l(Pe);hs=t(lt,"Series"),lt.forEach(s),ks=t(f,") called "),Ce=p(f,"CODE",{});var it=l(Ce);vs=t(it,"new_col"),it.forEach(s),ys=t(f," on the LHS, the RHS\u2019 lambda input(s) should be of type "),De=p(f,"CODE",{});var ct=l(De);ws=t(ct,"Series"),ct.forEach(s),_s=t(f,` as well.
This seems more intuitive because most operations are computations of one or more `),Oe=p(f,"CODE",{});var rt=l(Oe);Es=t(rt,"Series"),rt.forEach(s),bs=t(f,` (e.g. total_sales_column = item_price_column * quantity_sold_column).
However this is not the case as the lambda function takes in a `),Se=p(f,"CODE",{});var ut=l(Se);gs=t(ut,"DataFrame"),ut.forEach(s),Ps=t(f," as input, and expects a "),xe=p(f,"CODE",{});var dt=l(xe);Cs=t(dt,"Series"),dt.forEach(s),Ds=t(f," as output."),f.forEach(s),fa=u(e),$=p(e,"H1",{});var ft=l($);Os=t(ft,"Chaining methods (.apply, .applymap, .map, .pipe)"),ft.forEach(s),ma=u(e),ee=p(e,"P",{});var mt=l(ee);Ss=t(mt,"There are a variety of (overlapping) chaining methods that we can use, which does not help with implementing chaining as it can be confusing to choose which methods to use."),mt.forEach(s),ha=u(e),ae=p(e,"H2",{});var ht=l(ae);xs=t(ht,"Chaining functions on DataFrames"),ht.forEach(s),ka=u(e),h=p(e,"P",{});var D=l(h);Ts=t(D,"When working with "),Te=p(D,"CODE",{});var kt=l(Te);As=t(kt,"DataFrames"),kt.forEach(s),Hs=t(D,", you have the option of "),Ae=p(D,"CODE",{});var vt=l(Ae);Is=t(vt,".pipe"),vt.forEach(s),Ls=t(D,", "),He=p(D,"CODE",{});var yt=l(He);Rs=t(yt,".apply"),yt.forEach(s),qs=t(D," and "),Ie=p(D,"CODE",{});var wt=l(Ie);Us=t(wt,".applymap"),wt.forEach(s),Ns=t(D," to chain functions, which is also unintuitive at first glance (which one should I use? they all look like they do the same thing!)."),D.forEach(s),va=u(e),se=p(e,"P",{});var _t=l(se);Fs=t(_t,"As a general rule of thumb:"),_t.forEach(s),ya=u(e),g=p(e,"UL",{});var de=l(g);R=p(de,"LI",{});var Ha=l(R);Ms=t(Ha,"Default to using "),Le=p(Ha,"CODE",{});var Et=l(Le);Ws=t(Et,".pipe"),Et.forEach(s),zs=t(Ha,", so as to ease cognitive overhead in remembering which specific method to use. If pipe isn\u2019t suitable, try the below methods;"),Ha.forEach(s),js=u(de),q=p(de,"LI",{});var Ia=l(q);Bs=t(Ia,"Use "),Re=p(Ia,"CODE",{});var bt=l(Re);Gs=t(bt,".applymap"),bt.forEach(s),Js=t(Ia," when you need element-wise operation"),Ia.forEach(s),Ks=u(de),U=p(de,"LI",{});var La=l(U);Qs=t(La,"Use "),qe=p(La,"CODE",{});var gt=l(qe);Vs=t(gt,".apply"),gt.forEach(s),Xs=t(La," when you need to operate on row-wise aggregations/Series"),La.forEach(s),de.forEach(s),wa=u(e),w=p(e,"P",{});var G=l(w);Ys=t(G,"However, note that "),Ue=p(G,"CODE",{});var Pt=l(Ue);Zs=t(Pt,".applymap"),Pt.forEach(s),$s=t(G," and "),Ne=p(G,"CODE",{});var Ct=l(Ne);en=t(Ct,".apply"),Ct.forEach(s),an=t(G," applies the function to ALL elements/columns/rows, and in order to operate only on certain columns, you would have to do "),Fe=p(G,"CODE",{});var Dt=l(Fe);sn=t(Dt,"df['col'].applymap(my_func)"),Dt.forEach(s),G.forEach(s),_a=u(e),ne=p(e,"H2",{});var Ot=l(ne);nn=t(Ot,"Chaining functions on Series"),Ot.forEach(s),Ea=u(e),m=p(e,"P",{});var v=l(m);tn=t(v,"When working with "),Me=p(v,"CODE",{});var St=l(Me);on=t(St,"Series"),St.forEach(s),pn=t(v,", you have the option of "),We=p(v,"CODE",{});var xt=l(We);ln=t(xt,".pipe"),xt.forEach(s),cn=t(v,", "),ze=p(v,"CODE",{});var Tt=l(ze);rn=t(Tt,".apply"),Tt.forEach(s),un=t(v," and "),je=p(v,"CODE",{});var At=l(je);dn=t(At,".map"),At.forEach(s),fn=t(v,". Again, having multiple options that does "),Be=p(v,"EM",{});var Ht=l(Be);mn=t(Ht,"almost"),Ht.forEach(s),hn=t(v," the same things can be very confusing."),v.forEach(s),ba=u(e),te=p(e,"P",{});var It=l(te);kn=t(It,"As a general rule of thumb:"),It.forEach(s),ga=u(e),P=p(e,"UL",{});var fe=l(P);N=p(fe,"LI",{});var Ra=l(N);vn=t(Ra,"Default to using "),Ge=p(Ra,"CODE",{});var Lt=l(Ge);yn=t(Lt,".pipe"),Lt.forEach(s),wn=t(Ra,", so as to ease cognitive overhead in remembering which specific method to use. If pipe isn\u2019t suitable, try the below methods;"),Ra.forEach(s),_n=u(fe),F=p(fe,"LI",{});var qa=l(F);En=t(qa,"Use "),Je=p(qa,"CODE",{});var Rt=l(Je);bn=t(Rt,".map"),Rt.forEach(s),gn=t(qa," when you want to substitute elements using a dictionary (e.g. map \u2018A\u2019 to 1, \u2018B\u2019 to 2, etc.)"),qa.forEach(s),Pn=u(fe),M=p(fe,"LI",{});var Ua=l(M);Cn=t(Ua,"Use "),Ke=p(Ua,"CODE",{});var qt=l(Ke);Dn=t(qt,".apply"),qt.forEach(s),On=t(Ua," if you need to use Numpy functions"),Ua.forEach(s),fe.forEach(s),Pa=u(e),oe=p(e,"H1",{});var Ut=l(oe);Sn=t(Ut,"Speed"),Ut.forEach(s),Ca=u(e),C=p(e,"P",{});var me=l(C);xn=t(me,"Since most of these chaining methods uses "),Qe=p(me,"EM",{});var Nt=l(Qe);Tn=t(Nt,"Python"),Nt.forEach(s),An=t(me,`\u2019s for-loop in the background, it will NOT take advantage of the machine code vectorization that Pandas (and Numpy) has integrated into its normal \u2018unchained\u2019 API.
These vectorizations (e.g. `),Ve=p(me,"CODE",{});var Ft=l(Ve);Hn=t(Ft,"df['x'] / df['y']"),Ft.forEach(s),In=t(me,`) calls Numpy\u2019s underlying C code which helps to improve performance massively.
Hence there is a major trade off in writing (somewhat) more readable code, which is kind of disappointing as we have to trade off developer experience for runtime performance.`),me.forEach(s),Da=u(e),pe=p(e,"H1",{});var Mt=l(pe);Ln=t(Mt,"Conclusion and alternatives"),Mt.forEach(s),Oa=u(e),le=p(e,"P",{});var Wt=l(le);Rn=t(Wt,"It does seem like it is very hard to shoe-horn dplyr\u2019s more intuitive API into pandas\u2019, as they are fundamentally designed very differently."),Wt.forEach(s),Sa=u(e),k=p(e,"P",{});var x=l(k);qn=t(x,"Some alternatives that have nicer APIs include R\u2019s "),W=p(x,"A",{href:!0,rel:!0});var zt=l(W);Un=t(zt,"dplyr"),zt.forEach(s),Nn=t(x," as mentioned. If using python, there are also promising alternatives like "),z=p(x,"A",{href:!0,rel:!0});var jt=l(z);Fn=t(jt,"polars"),jt.forEach(s),Mn=t(x," and "),j=p(x,"A",{href:!0,rel:!0});var Bt=l(j);Wn=t(Bt,"ibis"),Bt.forEach(s),zn=t(x,"."),x.forEach(s),xa=u(e),ie=p(e,"H1",{});var Gt=l(ie);jn=t(Gt,"Code examples"),Gt.forEach(s),Ta=u(e),B=p(e,"PRE",{class:!0});var oo=l(B);oo.forEach(s),this.h()},h(){y(T,"class","language-py"),y(A,"class","language-py"),y(H,"class","language-py"),y(I,"class","language-py"),y(L,"class","language-py"),y(W,"href","https://dplyr.tidyverse.org/"),y(W,"rel","nofollow"),y(z,"href","https://www.pola.rs/"),y(z,"rel","nofollow"),y(j,"href","https://ibis-project.org/"),y(j,"rel","nofollow"),y(B,"class","language-python")},m(e,i){c(e,O,i),a(O,Na),c(e,Xe,i),c(e,J,i),a(J,Fa),c(e,Ye,i),c(e,K,i),a(K,Ma),c(e,Ze,i),c(e,_,i),a(_,Wa),a(_,he),a(he,za),a(_,ja),a(_,ke),a(ke,Ba),a(_,Ga),c(e,$e,i),c(e,Q,i),a(Q,Ja),c(e,ea,i),c(e,T,i),T.innerHTML=Qt,c(e,aa,i),c(e,V,i),a(V,Ka),c(e,sa,i),c(e,A,i),A.innerHTML=Vt,c(e,na,i),c(e,X,i),a(X,Qa),c(e,ta,i),c(e,H,i),H.innerHTML=Xt,c(e,oa,i),c(e,Y,i),a(Y,Va),c(e,pa,i),c(e,I,i),I.innerHTML=Yt,c(e,la,i),c(e,Z,i),a(Z,Xa),c(e,ia,i),c(e,E,i),a(E,Ya),a(E,ve),a(ve,Za),a(E,$a),a(E,ye),a(ye,es),a(E,as),c(e,ca,i),c(e,L,i),L.innerHTML=Zt,c(e,ra,i),c(e,b,i),a(b,ss),a(b,we),a(we,ns),a(b,ts),a(b,_e),a(_e,os),a(b,ps),c(e,ua,i),c(e,S,i),a(S,ls),a(S,Ee),a(Ee,is),a(S,cs),c(e,da,i),c(e,d,i),a(d,rs),a(d,be),a(be,us),a(d,ds),a(d,ge),a(ge,fs),a(d,ms),a(d,Pe),a(Pe,hs),a(d,ks),a(d,Ce),a(Ce,vs),a(d,ys),a(d,De),a(De,ws),a(d,_s),a(d,Oe),a(Oe,Es),a(d,bs),a(d,Se),a(Se,gs),a(d,Ps),a(d,xe),a(xe,Cs),a(d,Ds),c(e,fa,i),c(e,$,i),a($,Os),c(e,ma,i),c(e,ee,i),a(ee,Ss),c(e,ha,i),c(e,ae,i),a(ae,xs),c(e,ka,i),c(e,h,i),a(h,Ts),a(h,Te),a(Te,As),a(h,Hs),a(h,Ae),a(Ae,Is),a(h,Ls),a(h,He),a(He,Rs),a(h,qs),a(h,Ie),a(Ie,Us),a(h,Ns),c(e,va,i),c(e,se,i),a(se,Fs),c(e,ya,i),c(e,g,i),a(g,R),a(R,Ms),a(R,Le),a(Le,Ws),a(R,zs),a(g,js),a(g,q),a(q,Bs),a(q,Re),a(Re,Gs),a(q,Js),a(g,Ks),a(g,U),a(U,Qs),a(U,qe),a(qe,Vs),a(U,Xs),c(e,wa,i),c(e,w,i),a(w,Ys),a(w,Ue),a(Ue,Zs),a(w,$s),a(w,Ne),a(Ne,en),a(w,an),a(w,Fe),a(Fe,sn),c(e,_a,i),c(e,ne,i),a(ne,nn),c(e,Ea,i),c(e,m,i),a(m,tn),a(m,Me),a(Me,on),a(m,pn),a(m,We),a(We,ln),a(m,cn),a(m,ze),a(ze,rn),a(m,un),a(m,je),a(je,dn),a(m,fn),a(m,Be),a(Be,mn),a(m,hn),c(e,ba,i),c(e,te,i),a(te,kn),c(e,ga,i),c(e,P,i),a(P,N),a(N,vn),a(N,Ge),a(Ge,yn),a(N,wn),a(P,_n),a(P,F),a(F,En),a(F,Je),a(Je,bn),a(F,gn),a(P,Pn),a(P,M),a(M,Cn),a(M,Ke),a(Ke,Dn),a(M,On),c(e,Pa,i),c(e,oe,i),a(oe,Sn),c(e,Ca,i),c(e,C,i),a(C,xn),a(C,Qe),a(Qe,Tn),a(C,An),a(C,Ve),a(Ve,Hn),a(C,In),c(e,Da,i),c(e,pe,i),a(pe,Ln),c(e,Oa,i),c(e,le,i),a(le,Rn),c(e,Sa,i),c(e,k,i),a(k,qn),a(k,W),a(W,Un),a(k,Nn),a(k,z),a(z,Fn),a(k,Mn),a(k,j),a(j,Wn),a(k,zn),c(e,xa,i),c(e,ie,i),a(ie,jn),c(e,Ta,i),c(e,B,i),B.innerHTML=$t},p:Bn,i:Bn,o:Bn,d(e){e&&s(O),e&&s(Xe),e&&s(J),e&&s(Ye),e&&s(K),e&&s(Ze),e&&s(_),e&&s($e),e&&s(Q),e&&s(ea),e&&s(T),e&&s(aa),e&&s(V),e&&s(sa),e&&s(A),e&&s(na),e&&s(X),e&&s(ta),e&&s(H),e&&s(oa),e&&s(Y),e&&s(pa),e&&s(I),e&&s(la),e&&s(Z),e&&s(ia),e&&s(E),e&&s(ca),e&&s(L),e&&s(ra),e&&s(b),e&&s(ua),e&&s(S),e&&s(da),e&&s(d),e&&s(fa),e&&s($),e&&s(ma),e&&s(ee),e&&s(ha),e&&s(ae),e&&s(ka),e&&s(h),e&&s(va),e&&s(se),e&&s(ya),e&&s(g),e&&s(wa),e&&s(w),e&&s(_a),e&&s(ne),e&&s(Ea),e&&s(m),e&&s(ba),e&&s(te),e&&s(ga),e&&s(P),e&&s(Pa),e&&s(oe),e&&s(Ca),e&&s(C),e&&s(Da),e&&s(pe),e&&s(Oa),e&&s(le),e&&s(Sa),e&&s(k),e&&s(xa),e&&s(ie),e&&s(Ta),e&&s(B)}}}const ro={title:"Composable Pandas",date:"2023-03-03"},{title:Jt,date:fo}=ro;class mo extends po{constructor(O){super(),lo(this,O,null,co,io,{})}}export{mo as default,ro as metadata};
