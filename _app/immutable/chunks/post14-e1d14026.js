import{S as gs,i as Rs,s as Os,k as s,q as a,a as h,l,m as i,r as n,h as o,c,n as pn,b as d,B as t,A as fn}from"./index-4cbca6b4.js";function Ls(Ts){let D,Kt,it,g,Vt,P,Yt,Qt,rt,G,Xt,dt,y,ce,Zt,$t,pe,eo,to,fe,oo,ht,J,ao,ct,H,ue,no,so,pt,v,me,lo,io,ye,ro,ho,ft,W,Ee,co,po,ut,u,fo,be,uo,mo,ve,yo,Eo,we,bo,vo,ke,wo,ko,mt,w,xe,xo,_o,_e,To,Io,yt,N,Te,Do,go,Et,E,Ie,Ro,Oo,De,Lo,Po,S,Ho,ge,Wo,No,bt,M,So,vt,A,Re,Ao,Co,wt,R,Bo,Oe,jo,qo,kt,p,Le,zo,Go,Pe,Jo,Mo,U,Uo,He,k,Fo,We,Ko,Vo,Ne,Yo,Qo,Xo,Se,Zo,$o,x,ea,Ae,ta,oa,Ce,aa,na,sa,_,la,Be,ia,ra,je,da,ha,ca,T,pa,qe,fa,ua,ze,ma,ya,Ea,F,ba,C,Ge,va,wa,B,ka,Je,xa,_a,Ta,Me,Ia,Da,Ue,ga,xt,K,Ra,_t,O,Oa,Fe,La,Pa,Tt,L,Ha,Ke,Wa,Na,It,j,Ve,Sa,Aa,Dt,m,Ye,Ca,Ba,Qe,ja,qa,Xe,za,Ga,gt,I,Ze,Ja,Ma,$e,Ua,Fa,Rt,V,Ka,Ot,Y,Va,Lt,Q,Ya,Pt,X,Qa,Ht,Z,Xa,Wt,q,Is=`<code class="language-css"><span class="token selector">.grid-container</span> <span class="token punctuation">&#123;</span>
	<span class="token property">display</span><span class="token punctuation">:</span> grid<span class="token punctuation">;</span>
	<span class="token property">grid-template-columns</span><span class="token punctuation">:</span> <span class="token function">repeat</span><span class="token punctuation">(</span>auto-fill<span class="token punctuation">,</span> <span class="token function">minmax</span><span class="token punctuation">(</span><span class="token function">min</span><span class="token punctuation">(</span>200px<span class="token punctuation">,</span> 100%<span class="token punctuation">)</span><span class="token punctuation">,</span> 1fr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code>`,Nt,$,Za,St,ee,$a,At,te,et,en,Ct,oe,tt,tn,Bt,ae,ot,on,jt,ne,at,an;return{c(){D=s("h1"),Kt=a(_s),it=h(),g=s("p"),Vt=a("Recently read an extremely informative e-book on database indexing over at "),P=s("a"),Yt=a("use-the-index-luke"),Qt=a(`.
This post is to synthesise and summarise the main learnings that I took away from the ~200 page e-book.`),rt=h(),G=s("h1"),Xt=a("The Three Powers of Indexing"),dt=h(),y=s("ol"),ce=s("li"),Zt=a("B-Tree Traversal"),$t=h(),pe=s("li"),eo=a("Data Clustering"),to=h(),fe=s("li"),oo=a("Pipelined Sorting"),ht=h(),J=s("h2"),ao=a("Data Structures Underlying the Index"),ct=h(),H=s("p"),ue=s("strong"),no=a("Redundant/Duplicated Data"),so=a(`
An index is (usually) a separate data structure maintained by the database.
In other words, it is redundant data that is stored/managed on top of the actual data that is stored/managed in your table.
An index is powered by two key data structures: Doubly Linked List and B-Tree.
One node corresponds to one database block.`),pt=h(),v=s("p"),me=s("strong"),lo=a("Database block / Database page"),io=a(`
A database block or page is the smallest (size) unit of operation, usually about 4 kilobytes in size.
The data in one block is physically arranged in a `),ye=s("em"),ro=a("contiguous"),ho=a(` block of memory.
One block can usually store multiple rows of the table data, or multiple index entries.
This means that in order to read a single row within a block that contains multiple rows, the database will have to read the entire block.`),ft=h(),W=s("p"),Ee=s("strong"),co=a("Doubly Linked List"),po=a(`
The doubly linked lists\u2019 nodes are actually the leaf nodes for the B-tree.
Each node has multiple index entries, sorted by the index key.
Each entry in the node will store the index key(s) and also a pointer (ROWID) to the corresponding (physical) location of the data row.
Each node is also connected to the next higher entry (leaf) node and next lower (leaf) entry node, giving it the ability to move up and down the index keys in all the leaf nodes (double linked list).
This effectively makes the index entries and the index nodes all sorted.`),ut=h(),u=s("p"),fo=a("The important thing to note here is that accessing all ROWID rows contained in one single index node is most likely a "),be=s("strong"),uo=a("random operation"),mo=a(` because row data is stored in the heap and there are no guarantees that it is ordered.
This is further exacerbated by having to read the ROWIDs sequentially as they appear and also having to access row data `),ve=s("em"),yo=a("in blocks"),Eo=a(`.
The implication is that scanning through the ROWIDs could mean `),we=s("em"),bo=a("accessing the same blocks multiple times"),vo=a(" to read different rows in the same block, effectively making using the index "),ke=s("em"),wo=a("slower"),ko=a(` than a full etable scan!
Of course, the database optimizer will try avoid this using its cost metrics and estimation.`),mt=h(),w=s("p"),xe=s("strong"),xo=a("B-tree"),_o=a(`
The B-tree forms the upper \u2018layers\u2019 of the index. Each leaf node\u2019s highest value will be connected to the node in the layer above.
The node in the layer above consists of the highest (index key) values of several child nodes; depending on the block size, it can store ~100 values.
This process is repeated for every branch layer until the tree like structure (root node) is formed.
The `),_e=s("code"),To=a("B"),Io=a(` stands for balanced, which means that the depth of the deepest node is at most 1 layer deeper than the rest.
The B-tree allows log(n) lookups, therefore traversing the tree is very fast.`),yt=h(),N=s("p"),Te=s("strong"),Do=a("Index access patterns"),go=a(`
There are three different ways that the DB optimizer can use index predicates, with drastically different performance characteristics.`),Et=h(),E=s("ol"),Ie=s("li"),Ro=a("Index unique scan, where only tree traversal is necessary. This of course requires unique constraint to be in place. (Super fast)"),Oo=h(),De=s("li"),Lo=a("Index range scan, where the DB will perform both tree traversal as well as follow leaf nodes to find all matching entires. (Good enough)"),Po=h(),S=s("li"),Ho=a("Table access by index ROWID, where the DB will follow the ROWID pointer to read the row, then perform the filter based on what is found in the row. (Can be dangerous as it depends on table size "),ge=s("em"),Wo=a("not"),No=a(" query size)"),bt=h(),M=s("h2"),So=a("WHERE clause"),vt=h(),A=s("p"),Re=s("code"),Ao=a("WHERE"),Co=a(` clauses are the main utiliser of indexes.
The overarching theme and guideline here is to keep indexed columns as they are, and do functions/operations on the other side of the predicates.`),wt=h(),R=s("p"),Bo=a("Some key points to effectively write "),Oe=s("code"),jo=a("WHERE"),qo=a(" clause:"),kt=h(),p=s("ul"),Le=s("li"),zo=a("As much as possible, do not wrap indexed columns within functions, because optimiser treats these as black boxes."),Go=h(),Pe=s("li"),Jo=a("If functions are unavoidable, create a function based index."),Mo=h(),U=s("li"),Uo=a("The order of columns in the index definition is very important. Choose an order that can be used as often as possible."),He=s("ul"),k=s("li"),Fo=a("Queries can only use index when the "),We=s("code"),Ko=a("WHERE"),Vo=a(" clause contains \u201Ccumulation\u201D of the index columns starting from the left. E.g. For index with (col1, col2, col3), "),Ne=s("code"),Yo=a("WHERE"),Qo=a(" clause with either col1, col1 + col2, or col1 + col2 + col3 can use the index, whereas all other predicates are unable to use the index due to how the underlying index keys are sorted."),Xo=h(),Se=s("li"),Zo=a("When creating index, prioritise equality first then for range predicates."),$o=h(),x=s("li"),ea=a("For "),Ae=s("code"),ta=a("LIKE 'abc%xyz'"),oa=a(" predicates, only the part infront of the "),Ce=s("code"),aa=a("%"),na=a(" is used for access predicates."),sa=h(),_=s("li"),la=a("Avoid "),Be=s("code"),ia=a("LIKE"),ra=a(" on date types as it internally applies "),je=s("code"),da=a("TO_STRING()"),ha=a(" which obfuscates the index."),ca=h(),T=s("li"),pa=a("When working with numeric strings, make sure to supply a string as predicate to avoid type conversion which obfuscates index ("),qe=s("code"),fa=a("WHERE string_col = 42"),ua=a(" vs "),ze=s("code"),ma=a('WHERE string_col = "42"'),ya=a(")."),Ea=h(),F=s("li"),ba=a("Combining columns also obfuscates index (e.g. filtering on date_column + time_column)."),C=s("ul"),Ge=s("li"),va=a("If possible, add combined column into table and index"),wa=h(),B=s("li"),ka=a("If not possible, use \u201Credundant\u201D predicate on a single column so that predicate can take advantage of the index (e.g. "),Je=s("code"),xa=a("WHERE ADDTIME(date_col, time_col) > DATEADD(now(), INTERVAL '1 day') AND date_col >= DATE(DATE_ADD(now(), INTERVAL '1 day'))"),_a=a(", the second predicate is redundant but able to use index on date_col)."),Ta=h(),Me=s("li"),Ia=a("Partial indexing (indexing only certain rows) may be useful on certain workloads to reduce index size and improve update performance on non-indexed rows."),Da=h(),Ue=s("li"),ga=a("When index causes problems for a particular query,"),xt=h(),K=s("h2"),Ra=a("JOIN operations"),_t=h(),O=s("p"),Oa=a(`JOINs in databases are done 2 tables at a time. If multiple JOINs are needed then DB will do it recursively 2 tables at a time.
This means the optimiser has to evaluate the `),Fe=s("code"),La=a("n!"),Pa=a(` join order permutations to come up with the best execution plan.
Therefore, the more complex the query, the more important using prepared statements become.`),Tt=h(),L=s("p"),Ha=a("There are 3 types of "),Ke=s("code"),Wa=a("JOIN"),Na=a(" algorithms:"),It=h(),j=s("p"),Ve=s("strong"),Sa=a("Nested Loop Join"),Aa=a(`
Nested loop join operates like a nested for loop: for each join key in table 1, find the corresponding key in table 2.
To improve performance, index the join key columns.
This algorithm is performant when rows returned by the \u2018outer loop\u2019 is low.`),Dt=h(),m=s("p"),Ye=s("strong"),Ca=a("Hash Join"),Ba=a(`
Hash join operates by loading all the keys (and rows) of one table in-memory, so that the other table can keep looking up the corresponding join key.
Indexing join key columns for this algorithm is useless as the keys are already in-memory!
Hence, it is better to index the independent `),Qe=s("code"),ja=a("WHERE"),qa=a(` clause to improve performance.
Another way to improve hash join performance is to reduce the memory footprint of the hash table, this implies both selecting less rows `),Xe=s("em"),za=a("as well as less columns"),Ga=a("."),gt=h(),I=s("p"),Ze=s("strong"),Ja=a("Sort Merge Join"),Ma=a(`
Sort merge join operates by combining 2 `),$e=s("em"),Ua=a("sorted"),Fa=a(` tables (like a zipper). It iteratively loads the smallest keys from the two tables and do a cartesian product on them.
Sort merge join can be sped up if the keys are presorted (from an index or from another sort operation in the query).`),Rt=h(),V=s("h2"),Ka=a("ORDER BY and GROUP BY"),Ot=h(),Y=s("h2"),Va=a("Data Clustering"),Lt=h(),Q=s("h2"),Ya=a("Partial Results"),Pt=h(),X=s("h2"),Qa=a("INSERT, DELETE, UPDATE"),Ht=h(),Z=s("p"),Xa=a("Code:"),Wt=h(),q=s("pre"),Nt=h(),$=s("h2"),Za=a("Heading 2"),St=h(),ee=s("p"),$a=a("The quick brown fox jumps over the lazy dog."),At=h(),te=s("p"),et=s("strong"),en=a("Pipelining"),Ct=h(),oe=s("p"),tt=s("strong"),tn=a("Clustering Factor"),Bt=h(),ae=s("p"),ot=s("strong"),on=a("Covering Index"),jt=h(),ne=s("p"),at=s("strong"),an=a("Prepared Statements/Bind Parameters"),this.h()},l(e){D=l(e,"H1",{});var r=i(D);Kt=n(r,_s),r.forEach(o),it=c(e),g=l(e,"P",{});var qt=i(g);Vt=n(qt,"Recently read an extremely informative e-book on database indexing over at "),P=l(qt,"A",{href:!0,rel:!0});var un=i(P);Yt=n(un,"use-the-index-luke"),un.forEach(o),Qt=n(qt,`.
This post is to synthesise and summarise the main learnings that I took away from the ~200 page e-book.`),qt.forEach(o),rt=c(e),G=l(e,"H1",{});var mn=i(G);Xt=n(mn,"The Three Powers of Indexing"),mn.forEach(o),dt=c(e),y=l(e,"OL",{});var se=i(y);ce=l(se,"LI",{});var yn=i(ce);Zt=n(yn,"B-Tree Traversal"),yn.forEach(o),$t=c(se),pe=l(se,"LI",{});var En=i(pe);eo=n(En,"Data Clustering"),En.forEach(o),to=c(se),fe=l(se,"LI",{});var bn=i(fe);oo=n(bn,"Pipelined Sorting"),bn.forEach(o),se.forEach(o),ht=c(e),J=l(e,"H2",{});var vn=i(J);ao=n(vn,"Data Structures Underlying the Index"),vn.forEach(o),ct=c(e),H=l(e,"P",{});var nn=i(H);ue=l(nn,"STRONG",{});var wn=i(ue);no=n(wn,"Redundant/Duplicated Data"),wn.forEach(o),so=n(nn,`
An index is (usually) a separate data structure maintained by the database.
In other words, it is redundant data that is stored/managed on top of the actual data that is stored/managed in your table.
An index is powered by two key data structures: Doubly Linked List and B-Tree.
One node corresponds to one database block.`),nn.forEach(o),pt=c(e),v=l(e,"P",{});var nt=i(v);me=l(nt,"STRONG",{});var kn=i(me);lo=n(kn,"Database block / Database page"),kn.forEach(o),io=n(nt,`
A database block or page is the smallest (size) unit of operation, usually about 4 kilobytes in size.
The data in one block is physically arranged in a `),ye=l(nt,"EM",{});var xn=i(ye);ro=n(xn,"contiguous"),xn.forEach(o),ho=n(nt,` block of memory.
One block can usually store multiple rows of the table data, or multiple index entries.
This means that in order to read a single row within a block that contains multiple rows, the database will have to read the entire block.`),nt.forEach(o),ft=c(e),W=l(e,"P",{});var sn=i(W);Ee=l(sn,"STRONG",{});var _n=i(Ee);co=n(_n,"Doubly Linked List"),_n.forEach(o),po=n(sn,`
The doubly linked lists\u2019 nodes are actually the leaf nodes for the B-tree.
Each node has multiple index entries, sorted by the index key.
Each entry in the node will store the index key(s) and also a pointer (ROWID) to the corresponding (physical) location of the data row.
Each node is also connected to the next higher entry (leaf) node and next lower (leaf) entry node, giving it the ability to move up and down the index keys in all the leaf nodes (double linked list).
This effectively makes the index entries and the index nodes all sorted.`),sn.forEach(o),ut=c(e),u=l(e,"P",{});var b=i(u);fo=n(b,"The important thing to note here is that accessing all ROWID rows contained in one single index node is most likely a "),be=l(b,"STRONG",{});var Tn=i(be);uo=n(Tn,"random operation"),Tn.forEach(o),mo=n(b,` because row data is stored in the heap and there are no guarantees that it is ordered.
This is further exacerbated by having to read the ROWIDs sequentially as they appear and also having to access row data `),ve=l(b,"EM",{});var In=i(ve);yo=n(In,"in blocks"),In.forEach(o),Eo=n(b,`.
The implication is that scanning through the ROWIDs could mean `),we=l(b,"EM",{});var Dn=i(we);bo=n(Dn,"accessing the same blocks multiple times"),Dn.forEach(o),vo=n(b," to read different rows in the same block, effectively making using the index "),ke=l(b,"EM",{});var gn=i(ke);wo=n(gn,"slower"),gn.forEach(o),ko=n(b,` than a full etable scan!
Of course, the database optimizer will try avoid this using its cost metrics and estimation.`),b.forEach(o),mt=c(e),w=l(e,"P",{});var st=i(w);xe=l(st,"STRONG",{});var Rn=i(xe);xo=n(Rn,"B-tree"),Rn.forEach(o),_o=n(st,`
The B-tree forms the upper \u2018layers\u2019 of the index. Each leaf node\u2019s highest value will be connected to the node in the layer above.
The node in the layer above consists of the highest (index key) values of several child nodes; depending on the block size, it can store ~100 values.
This process is repeated for every branch layer until the tree like structure (root node) is formed.
The `),_e=l(st,"CODE",{});var On=i(_e);To=n(On,"B"),On.forEach(o),Io=n(st,` stands for balanced, which means that the depth of the deepest node is at most 1 layer deeper than the rest.
The B-tree allows log(n) lookups, therefore traversing the tree is very fast.`),st.forEach(o),yt=c(e),N=l(e,"P",{});var ln=i(N);Te=l(ln,"STRONG",{});var Ln=i(Te);Do=n(Ln,"Index access patterns"),Ln.forEach(o),go=n(ln,`
There are three different ways that the DB optimizer can use index predicates, with drastically different performance characteristics.`),ln.forEach(o),Et=c(e),E=l(e,"OL",{});var le=i(E);Ie=l(le,"LI",{});var Pn=i(Ie);Ro=n(Pn,"Index unique scan, where only tree traversal is necessary. This of course requires unique constraint to be in place. (Super fast)"),Pn.forEach(o),Oo=c(le),De=l(le,"LI",{});var Hn=i(De);Lo=n(Hn,"Index range scan, where the DB will perform both tree traversal as well as follow leaf nodes to find all matching entires. (Good enough)"),Hn.forEach(o),Po=c(le),S=l(le,"LI",{});var zt=i(S);Ho=n(zt,"Table access by index ROWID, where the DB will follow the ROWID pointer to read the row, then perform the filter based on what is found in the row. (Can be dangerous as it depends on table size "),ge=l(zt,"EM",{});var Wn=i(ge);Wo=n(Wn,"not"),Wn.forEach(o),No=n(zt," query size)"),zt.forEach(o),le.forEach(o),bt=c(e),M=l(e,"H2",{});var Nn=i(M);So=n(Nn,"WHERE clause"),Nn.forEach(o),vt=c(e),A=l(e,"P",{});var rn=i(A);Re=l(rn,"CODE",{});var Sn=i(Re);Ao=n(Sn,"WHERE"),Sn.forEach(o),Co=n(rn,` clauses are the main utiliser of indexes.
The overarching theme and guideline here is to keep indexed columns as they are, and do functions/operations on the other side of the predicates.`),rn.forEach(o),wt=c(e),R=l(e,"P",{});var Gt=i(R);Bo=n(Gt,"Some key points to effectively write "),Oe=l(Gt,"CODE",{});var An=i(Oe);jo=n(An,"WHERE"),An.forEach(o),qo=n(Gt," clause:"),Gt.forEach(o),kt=c(e),p=l(e,"UL",{});var f=i(p);Le=l(f,"LI",{});var Cn=i(Le);zo=n(Cn,"As much as possible, do not wrap indexed columns within functions, because optimiser treats these as black boxes."),Cn.forEach(o),Go=c(f),Pe=l(f,"LI",{});var Bn=i(Pe);Jo=n(Bn,"If functions are unavoidable, create a function based index."),Bn.forEach(o),Mo=c(f),U=l(f,"LI",{});var dn=i(U);Uo=n(dn,"The order of columns in the index definition is very important. Choose an order that can be used as often as possible."),He=l(dn,"UL",{});var jn=i(He);k=l(jn,"LI",{});var ie=i(k);Fo=n(ie,"Queries can only use index when the "),We=l(ie,"CODE",{});var qn=i(We);Ko=n(qn,"WHERE"),qn.forEach(o),Vo=n(ie," clause contains \u201Ccumulation\u201D of the index columns starting from the left. E.g. For index with (col1, col2, col3), "),Ne=l(ie,"CODE",{});var zn=i(Ne);Yo=n(zn,"WHERE"),zn.forEach(o),Qo=n(ie," clause with either col1, col1 + col2, or col1 + col2 + col3 can use the index, whereas all other predicates are unable to use the index due to how the underlying index keys are sorted."),ie.forEach(o),jn.forEach(o),dn.forEach(o),Xo=c(f),Se=l(f,"LI",{});var Gn=i(Se);Zo=n(Gn,"When creating index, prioritise equality first then for range predicates."),Gn.forEach(o),$o=c(f),x=l(f,"LI",{});var re=i(x);ea=n(re,"For "),Ae=l(re,"CODE",{});var Jn=i(Ae);ta=n(Jn,"LIKE 'abc%xyz'"),Jn.forEach(o),oa=n(re," predicates, only the part infront of the "),Ce=l(re,"CODE",{});var Mn=i(Ce);aa=n(Mn,"%"),Mn.forEach(o),na=n(re," is used for access predicates."),re.forEach(o),sa=c(f),_=l(f,"LI",{});var de=i(_);la=n(de,"Avoid "),Be=l(de,"CODE",{});var Un=i(Be);ia=n(Un,"LIKE"),Un.forEach(o),ra=n(de," on date types as it internally applies "),je=l(de,"CODE",{});var Fn=i(je);da=n(Fn,"TO_STRING()"),Fn.forEach(o),ha=n(de," which obfuscates the index."),de.forEach(o),ca=c(f),T=l(f,"LI",{});var he=i(T);pa=n(he,"When working with numeric strings, make sure to supply a string as predicate to avoid type conversion which obfuscates index ("),qe=l(he,"CODE",{});var Kn=i(qe);fa=n(Kn,"WHERE string_col = 42"),Kn.forEach(o),ua=n(he," vs "),ze=l(he,"CODE",{});var Vn=i(ze);ma=n(Vn,'WHERE string_col = "42"'),Vn.forEach(o),ya=n(he,")."),he.forEach(o),Ea=c(f),F=l(f,"LI",{});var hn=i(F);ba=n(hn,"Combining columns also obfuscates index (e.g. filtering on date_column + time_column)."),C=l(hn,"UL",{});var Jt=i(C);Ge=l(Jt,"LI",{});var Yn=i(Ge);va=n(Yn,"If possible, add combined column into table and index"),Yn.forEach(o),wa=c(Jt),B=l(Jt,"LI",{});var Mt=i(B);ka=n(Mt,"If not possible, use \u201Credundant\u201D predicate on a single column so that predicate can take advantage of the index (e.g. "),Je=l(Mt,"CODE",{});var Qn=i(Je);xa=n(Qn,"WHERE ADDTIME(date_col, time_col) > DATEADD(now(), INTERVAL '1 day') AND date_col >= DATE(DATE_ADD(now(), INTERVAL '1 day'))"),Qn.forEach(o),_a=n(Mt,", the second predicate is redundant but able to use index on date_col)."),Mt.forEach(o),Jt.forEach(o),hn.forEach(o),Ta=c(f),Me=l(f,"LI",{});var Xn=i(Me);Ia=n(Xn,"Partial indexing (indexing only certain rows) may be useful on certain workloads to reduce index size and improve update performance on non-indexed rows."),Xn.forEach(o),Da=c(f),Ue=l(f,"LI",{});var Zn=i(Ue);ga=n(Zn,"When index causes problems for a particular query,"),Zn.forEach(o),f.forEach(o),xt=c(e),K=l(e,"H2",{});var $n=i(K);Ra=n($n,"JOIN operations"),$n.forEach(o),_t=c(e),O=l(e,"P",{});var Ut=i(O);Oa=n(Ut,`JOINs in databases are done 2 tables at a time. If multiple JOINs are needed then DB will do it recursively 2 tables at a time.
This means the optimiser has to evaluate the `),Fe=l(Ut,"CODE",{});var es=i(Fe);La=n(es,"n!"),es.forEach(o),Pa=n(Ut,` join order permutations to come up with the best execution plan.
Therefore, the more complex the query, the more important using prepared statements become.`),Ut.forEach(o),Tt=c(e),L=l(e,"P",{});var Ft=i(L);Ha=n(Ft,"There are 3 types of "),Ke=l(Ft,"CODE",{});var ts=i(Ke);Wa=n(ts,"JOIN"),ts.forEach(o),Na=n(Ft," algorithms:"),Ft.forEach(o),It=c(e),j=l(e,"P",{});var cn=i(j);Ve=l(cn,"STRONG",{});var os=i(Ve);Sa=n(os,"Nested Loop Join"),os.forEach(o),Aa=n(cn,`
Nested loop join operates like a nested for loop: for each join key in table 1, find the corresponding key in table 2.
To improve performance, index the join key columns.
This algorithm is performant when rows returned by the \u2018outer loop\u2019 is low.`),cn.forEach(o),Dt=c(e),m=l(e,"P",{});var z=i(m);Ye=l(z,"STRONG",{});var as=i(Ye);Ca=n(as,"Hash Join"),as.forEach(o),Ba=n(z,`
Hash join operates by loading all the keys (and rows) of one table in-memory, so that the other table can keep looking up the corresponding join key.
Indexing join key columns for this algorithm is useless as the keys are already in-memory!
Hence, it is better to index the independent `),Qe=l(z,"CODE",{});var ns=i(Qe);ja=n(ns,"WHERE"),ns.forEach(o),qa=n(z,` clause to improve performance.
Another way to improve hash join performance is to reduce the memory footprint of the hash table, this implies both selecting less rows `),Xe=l(z,"EM",{});var ss=i(Xe);za=n(ss,"as well as less columns"),ss.forEach(o),Ga=n(z,"."),z.forEach(o),gt=c(e),I=l(e,"P",{});var lt=i(I);Ze=l(lt,"STRONG",{});var ls=i(Ze);Ja=n(ls,"Sort Merge Join"),ls.forEach(o),Ma=n(lt,`
Sort merge join operates by combining 2 `),$e=l(lt,"EM",{});var is=i($e);Ua=n(is,"sorted"),is.forEach(o),Fa=n(lt,` tables (like a zipper). It iteratively loads the smallest keys from the two tables and do a cartesian product on them.
Sort merge join can be sped up if the keys are presorted (from an index or from another sort operation in the query).`),lt.forEach(o),Rt=c(e),V=l(e,"H2",{});var rs=i(V);Ka=n(rs,"ORDER BY and GROUP BY"),rs.forEach(o),Ot=c(e),Y=l(e,"H2",{});var ds=i(Y);Va=n(ds,"Data Clustering"),ds.forEach(o),Lt=c(e),Q=l(e,"H2",{});var hs=i(Q);Ya=n(hs,"Partial Results"),hs.forEach(o),Pt=c(e),X=l(e,"H2",{});var cs=i(X);Qa=n(cs,"INSERT, DELETE, UPDATE"),cs.forEach(o),Ht=c(e),Z=l(e,"P",{});var ps=i(Z);Xa=n(ps,"Code:"),ps.forEach(o),Wt=c(e),q=l(e,"PRE",{class:!0});var Ds=i(q);Ds.forEach(o),Nt=c(e),$=l(e,"H2",{});var fs=i($);Za=n(fs,"Heading 2"),fs.forEach(o),St=c(e),ee=l(e,"P",{});var us=i(ee);$a=n(us,"The quick brown fox jumps over the lazy dog."),us.forEach(o),At=c(e),te=l(e,"P",{});var ms=i(te);et=l(ms,"STRONG",{});var ys=i(et);en=n(ys,"Pipelining"),ys.forEach(o),ms.forEach(o),Ct=c(e),oe=l(e,"P",{});var Es=i(oe);tt=l(Es,"STRONG",{});var bs=i(tt);tn=n(bs,"Clustering Factor"),bs.forEach(o),Es.forEach(o),Bt=c(e),ae=l(e,"P",{});var vs=i(ae);ot=l(vs,"STRONG",{});var ws=i(ot);on=n(ws,"Covering Index"),ws.forEach(o),vs.forEach(o),jt=c(e),ne=l(e,"P",{});var ks=i(ne);at=l(ks,"STRONG",{});var xs=i(at);an=n(xs,"Prepared Statements/Bind Parameters"),xs.forEach(o),ks.forEach(o),this.h()},h(){pn(P,"href","https://use-the-index-luke.com/"),pn(P,"rel","nofollow"),pn(q,"class","language-css")},m(e,r){d(e,D,r),t(D,Kt),d(e,it,r),d(e,g,r),t(g,Vt),t(g,P),t(P,Yt),t(g,Qt),d(e,rt,r),d(e,G,r),t(G,Xt),d(e,dt,r),d(e,y,r),t(y,ce),t(ce,Zt),t(y,$t),t(y,pe),t(pe,eo),t(y,to),t(y,fe),t(fe,oo),d(e,ht,r),d(e,J,r),t(J,ao),d(e,ct,r),d(e,H,r),t(H,ue),t(ue,no),t(H,so),d(e,pt,r),d(e,v,r),t(v,me),t(me,lo),t(v,io),t(v,ye),t(ye,ro),t(v,ho),d(e,ft,r),d(e,W,r),t(W,Ee),t(Ee,co),t(W,po),d(e,ut,r),d(e,u,r),t(u,fo),t(u,be),t(be,uo),t(u,mo),t(u,ve),t(ve,yo),t(u,Eo),t(u,we),t(we,bo),t(u,vo),t(u,ke),t(ke,wo),t(u,ko),d(e,mt,r),d(e,w,r),t(w,xe),t(xe,xo),t(w,_o),t(w,_e),t(_e,To),t(w,Io),d(e,yt,r),d(e,N,r),t(N,Te),t(Te,Do),t(N,go),d(e,Et,r),d(e,E,r),t(E,Ie),t(Ie,Ro),t(E,Oo),t(E,De),t(De,Lo),t(E,Po),t(E,S),t(S,Ho),t(S,ge),t(ge,Wo),t(S,No),d(e,bt,r),d(e,M,r),t(M,So),d(e,vt,r),d(e,A,r),t(A,Re),t(Re,Ao),t(A,Co),d(e,wt,r),d(e,R,r),t(R,Bo),t(R,Oe),t(Oe,jo),t(R,qo),d(e,kt,r),d(e,p,r),t(p,Le),t(Le,zo),t(p,Go),t(p,Pe),t(Pe,Jo),t(p,Mo),t(p,U),t(U,Uo),t(U,He),t(He,k),t(k,Fo),t(k,We),t(We,Ko),t(k,Vo),t(k,Ne),t(Ne,Yo),t(k,Qo),t(p,Xo),t(p,Se),t(Se,Zo),t(p,$o),t(p,x),t(x,ea),t(x,Ae),t(Ae,ta),t(x,oa),t(x,Ce),t(Ce,aa),t(x,na),t(p,sa),t(p,_),t(_,la),t(_,Be),t(Be,ia),t(_,ra),t(_,je),t(je,da),t(_,ha),t(p,ca),t(p,T),t(T,pa),t(T,qe),t(qe,fa),t(T,ua),t(T,ze),t(ze,ma),t(T,ya),t(p,Ea),t(p,F),t(F,ba),t(F,C),t(C,Ge),t(Ge,va),t(C,wa),t(C,B),t(B,ka),t(B,Je),t(Je,xa),t(B,_a),t(p,Ta),t(p,Me),t(Me,Ia),t(p,Da),t(p,Ue),t(Ue,ga),d(e,xt,r),d(e,K,r),t(K,Ra),d(e,_t,r),d(e,O,r),t(O,Oa),t(O,Fe),t(Fe,La),t(O,Pa),d(e,Tt,r),d(e,L,r),t(L,Ha),t(L,Ke),t(Ke,Wa),t(L,Na),d(e,It,r),d(e,j,r),t(j,Ve),t(Ve,Sa),t(j,Aa),d(e,Dt,r),d(e,m,r),t(m,Ye),t(Ye,Ca),t(m,Ba),t(m,Qe),t(Qe,ja),t(m,qa),t(m,Xe),t(Xe,za),t(m,Ga),d(e,gt,r),d(e,I,r),t(I,Ze),t(Ze,Ja),t(I,Ma),t(I,$e),t($e,Ua),t(I,Fa),d(e,Rt,r),d(e,V,r),t(V,Ka),d(e,Ot,r),d(e,Y,r),t(Y,Va),d(e,Lt,r),d(e,Q,r),t(Q,Ya),d(e,Pt,r),d(e,X,r),t(X,Qa),d(e,Ht,r),d(e,Z,r),t(Z,Xa),d(e,Wt,r),d(e,q,r),q.innerHTML=Is,d(e,Nt,r),d(e,$,r),t($,Za),d(e,St,r),d(e,ee,r),t(ee,$a),d(e,At,r),d(e,te,r),t(te,et),t(et,en),d(e,Ct,r),d(e,oe,r),t(oe,tt),t(tt,tn),d(e,Bt,r),d(e,ae,r),t(ae,ot),t(ot,on),d(e,jt,r),d(e,ne,r),t(ne,at),t(at,an)},p:fn,i:fn,o:fn,d(e){e&&o(D),e&&o(it),e&&o(g),e&&o(rt),e&&o(G),e&&o(dt),e&&o(y),e&&o(ht),e&&o(J),e&&o(ct),e&&o(H),e&&o(pt),e&&o(v),e&&o(ft),e&&o(W),e&&o(ut),e&&o(u),e&&o(mt),e&&o(w),e&&o(yt),e&&o(N),e&&o(Et),e&&o(E),e&&o(bt),e&&o(M),e&&o(vt),e&&o(A),e&&o(wt),e&&o(R),e&&o(kt),e&&o(p),e&&o(xt),e&&o(K),e&&o(_t),e&&o(O),e&&o(Tt),e&&o(L),e&&o(It),e&&o(j),e&&o(Dt),e&&o(m),e&&o(gt),e&&o(I),e&&o(Rt),e&&o(V),e&&o(Ot),e&&o(Y),e&&o(Lt),e&&o(Q),e&&o(Pt),e&&o(X),e&&o(Ht),e&&o(Z),e&&o(Wt),e&&o(q),e&&o(Nt),e&&o($),e&&o(St),e&&o(ee),e&&o(At),e&&o(te),e&&o(Ct),e&&o(oe),e&&o(Bt),e&&o(ae),e&&o(jt),e&&o(ne)}}}const Ps={title:"Database Indexes",date:"2023-06-07"},{title:_s,date:Ws}=Ps;class Ns extends gs{constructor(D){super(),Rs(this,D,null,Ls,Os,{})}}export{Ns as default,Ps as metadata};
